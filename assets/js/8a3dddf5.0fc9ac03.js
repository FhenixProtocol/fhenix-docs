"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[9916],{3161:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var a=t(4848),r=t(8453);const s={sidebar_position:2},i="Writing the Contract",c={id:"tutorial/Basic/Writing-The-Contract",title:"Writing the Contract",description:"Let's get started with writing our contract.",source:"@site/docs/tutorial/Basic/Writing-The-Contract.md",sourceDirName:"tutorial/Basic",slug:"/tutorial/Basic/Writing-The-Contract",permalink:"/docs/tutorial/Basic/Writing-The-Contract",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/tree/main/docs/tutorial/Basic/Writing-The-Contract.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Setting Up",permalink:"/docs/tutorial/Basic/Setting Up"},next:{title:"Adding View Functions",permalink:"/docs/tutorial/Basic/Adding View Functions"}},o={},l=[{value:"Importing FHE Libraries",id:"importing-fhe-libraries",level:3},{value:"Creating the Contract",id:"creating-the-contract",level:3},{value:"Inherit from ERC20",id:"inherit-from-erc20",level:4},{value:"Create Encrypted Balances",id:"create-encrypted-balances",level:4},{value:"Constructor",id:"constructor",level:4},{value:"Wrap",id:"wrap",level:4},{value:"Unwrap",id:"unwrap",level:4},{value:"Encrypted Transfers",id:"encrypted-transfers",level:4},{value:"Wait a second...",id:"wait-a-second",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"writing-the-contract",children:"Writing the Contract"}),"\n",(0,a.jsx)(n.p,{children:"Let's get started with writing our contract."}),"\n",(0,a.jsxs)(n.p,{children:["We'll start by looking around the template, and noticing that we have a ",(0,a.jsx)(n.code,{children:"Counter.sol"})," file in the ",(0,a.jsx)(n.code,{children:"contracts/"})," folder."]}),"\n",(0,a.jsxs)(n.p,{children:["Let's create a new file, and call that ",(0,a.jsx)(n.code,{children:"WrappingERC20.sol"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"touch contracts/WrappingERC20.sol\n"})}),"\n",(0,a.jsx)(n.p,{children:"Our goal is to create an ERC20 contract that supports shielded balances.\nLet's run through the different functions, step-by-step and show how we can implement each. We'll also link to more detailed explanations about custom functionality we make use of."}),"\n",(0,a.jsx)(n.h3,{id:"importing-fhe-libraries",children:"Importing FHE Libraries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport "@fhenixprotocol/contracts/FHE.sol";\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The OpenZeppelin ERC20 contract will provide the basic functionality of the ERC20 token, while ",(0,a.jsx)(n.code,{children:"FHE.sol"})," is necessary to create and use FHE."]}),"\n",(0,a.jsx)(n.p,{children:"We'll also have to install the OpenZeppelin contracts, since they are not part of the default template."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"pnpm install @openzeppelin/contracts\n"})}),"\n",(0,a.jsx)(n.h3,{id:"creating-the-contract",children:"Creating the Contract"}),"\n",(0,a.jsx)(n.h4,{id:"inherit-from-erc20",children:"Inherit from ERC20"}),"\n",(0,a.jsxs)(n.p,{children:["The contract WrappingERC20 is an ERC20 contract. It uses encryption from ",(0,a.jsx)(n.code,{children:"FHE.sol"})," to keep balances private and only viewable by the holder of the correct decryption key."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"contract WrappingERC20 is ERC20 {\n\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"create-encrypted-balances",children:"Create Encrypted Balances"}),"\n",(0,a.jsx)(n.p,{children:"An encrypted balance is initialized for each address, _encBalances, which will hold encrypted token balances for users. euints are encrypted data types that represent FHE-encrypted unsigned integers of various bit lengths."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"mapping(address => euint32) internal _encBalances;\n"})}),"\n",(0,a.jsx)(n.h4,{id:"constructor",children:"Constructor"}),"\n",(0,a.jsx)(n.p,{children:"The constructor function sets the name and symbol of the token, and then mints an initial 100 tokens to the address that deploys the contract."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n     _mint(msg.sender, 100 * 10 ** uint(decimals()));\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"wrap",children:"Wrap"}),"\n",(0,a.jsxs)(n.p,{children:["First, let's define a function ",(0,a.jsx)(n.code,{children:"wrap(uint32 amount)"})," that allows users to convert (wrap) their tokens into encrypted form.\nThe function will burn a specified amount from the user's balance and add the same amount to their encrypted balance."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function wrap(uint32 amount) public {\n    // Make sure that the sender has enough of the public balance\n    require(balanceOf(msg.sender) >= amount);\n    // Burn public balance\n    _burn(msg.sender, amount);\n\n    // convert public amount to shielded by encrypting it\n    euint32 shieldedAmount = FHE.asEuint32(amount);\n    // Add shielded balance to his current balance\n    _encBalances[msg.sender] = _encBalances[msg.sender] + shieldedAmount;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Breaking this down, the following logic is performed:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Verify that the user has enough public tokens to wrap"}),"\n",(0,a.jsx)(n.li,{children:"Burn public tokens"}),"\n",(0,a.jsx)(n.li,{children:"Add shielded tokens to the caller's balance"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"There are two main FHE operations that happened here:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"FHE.asEuint32(amount)"})," - this converted a standard, public ",(0,a.jsx)(n.code,{children:"uint"})," to an FHE-encrypted number"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"_encBalances[msg.sender] + shieldedAmount"})," - this performs homomorphic addition between the two encrypted numbers ",(0,a.jsx)(n.code,{children:"shieldedAmount"})," and ",(0,a.jsx)(n.code,{children:"_encBalances[msg.sender]"})]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["Even though we called ",(0,a.jsx)(n.code,{children:"FHE.asEuint32()"})," on a public value and encrypted it we did not actually hide any information - the plaintext value was already known beforehand"]})}),"\n",(0,a.jsx)(n.h4,{id:"unwrap",children:"Unwrap"}),"\n",(0,a.jsxs)(n.p,{children:["Next, let's define ",(0,a.jsx)(n.code,{children:"unwrap(inEuint32 amount)"}),". This function will allow users to convert (unwrap) their encrypted tokens back into public tokens.\nThe function will remove the specified amount from the user's encrypted balance and add the same amount to the user's public balance."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function unwrap(inEuint32 memory amount) public {\n    euint32 _amount = FHE.asEuint32(amount)\n    // verify that our shielded balance is greater or equal than the requested amount. (gte = greater-than-or-equal)\n    FHE.req(_encBalances[msg.sender].gte(_amount));\n    // subtract amount from shielded balance\n    _encBalances[msg.sender] = _encBalances[msg.sender] - _amount;\n    // add amount to caller's public balance by calling the `mint` function\n    _mint(msg.sender, FHE.decrypt(_amount));\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Here we can see a few interesting things:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"FHE.req"})," (or FHE require) verifies that a statement is true, or reverts the function. We use this to verify that we have enough shielded amount."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"_encBalances[msg.sender].gte(_amount)"})," checks that ",(0,a.jsx)(n.code,{children:"_encBalances[msg.sender]"})," is ",(0,a.jsx)(n.strong,{children:"g"}),"rea",(0,a.jsx)(n.strong,{children:"t"}),"er or ",(0,a.jsx)(n.strong,{children:"e"}),"qual than ",(0,a.jsx)(n.code,{children:"_amount"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"inEuint32"})," is a data type specifically for input parameters. You can read more about it ",(0,a.jsx)(n.a,{href:"/docs/devdocs/Writing%20Smart%20Contracts/User-Inputs",children:"here"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"encrypted-transfers",children:"Encrypted Transfers"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"transferEncrypted(address to, bytes calldata encryptedAmount)"})," is a public function that transfers encrypted tokens from the function caller to the to address. It converts the encrypted amount into the encrypted integer form ",(0,a.jsx)(n.code,{children:"euint32"})," using the ",(0,a.jsx)(n.code,{children:"FHE.asEuint32(encryptedAmount)"})," function and then calls ",(0,a.jsx)(n.code,{children:"_transferEncrypted"}),".\nThe function ",(0,a.jsx)(n.code,{children:"_transferEncrypted(address to, euint32 amount)"})," is an internal function that just calls _transferImpl.\n",(0,a.jsx)(n.code,{children:"_transferImpl(address from, address to, euint32 amount)"})," performs the actual transfer. It checks if the sender has enough tokens, then adds the amount to the to address encrypted balance and subtracts the same amount from the from address encrypted balance."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function transferEncrypted(address to, inEuint32 calldata encryptedAmount) public {\n    euint32 amount = FHE.asEuint32(encryptedAmount);\n    // Make sure the sender has enough tokens. (lte = less-then-or-equal)\n    FHE.req(amount.lte(_encBalances[msg.sender]));\n\n    // Add to the balance of `to` and subract from the balance of `msg.sender`.\n    _encBalances[to] = _encBalances[to] + amount;\n    _encBalances[msg.sender] = _encBalances[msg.sender] - amount;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"And that's it! To recap, we just created a contract that allows users to wrap and unwrap their tokens, and transfer them in encrypted form."}),"\n",(0,a.jsx)(n.p,{children:"Let's see what the entire code looks like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport "@fhenixprotocol/contracts/FHE.sol";\n\ncontract WrappingERC20 is ERC20 {\n\n    mapping(address => euint32) internal _encBalances;\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _mint(msg.sender, 100 * 10 ** uint(decimals()));\n    }\n\n    function wrap(uint32 amount) public {\n        // Make sure that the sender has enough of the public balance\n        require(balanceOf(msg.sender) >= amount);\n        // Burn public balance\n        _burn(msg.sender, amount);\n\n        // convert public amount to shielded by encrypting it\n        euint32 shieldedAmount = FHE.asEuint32(amount);\n        // Add shielded balance to his current balance\n        _encBalances[msg.sender] = _encBalances[msg.sender] + shieldedAmount;\n    }\n\n    function unwrap(inEuint32 memory amount) public {\n        euint32 _amount = FHE.asEuint32(amount);\n        // verify that our shielded balance is greater or equal than the requested amount \n        FHE.req(_encBalances[msg.sender].gte(_amount));\n        // subtract amount from shielded balance\n        _encBalances[msg.sender] = _encBalances[msg.sender] - _amount;\n        // add amount to caller\'s public balance by calling the `mint` function\n        _mint(msg.sender, FHE.decrypt(_amount));\n    }\n\n    function transferEncrypted(address to, inEuint32 calldata encryptedAmount) public {\n        euint32 amount = FHE.asEuint32(encryptedAmount);\n        // Make sure the sender has enough tokens.\n        FHE.req(amount.lte(_encBalances[msg.sender]));\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        _encBalances[to] = _encBalances[to] + amount;\n        _encBalances[msg.sender] = _encBalances[msg.sender] - amount;\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note that in a real use case the actual code would include more functionality, and structure things a bit differently.\nIf you want to see what such a contract looks like, you can check out the ",(0,a.jsx)(n.a,{href:"https://github.com/FhenixProtocol/fhenix-contracts/blob/main/contracts/experimental/token/FHERC20/FHERC20.sol",children:"FHERC20"})," contract in the Fhenix contracts repository."]}),"\n",(0,a.jsx)(n.h3,{id:"wait-a-second",children:"Wait a second..."}),"\n",(0,a.jsxs)(n.p,{children:["But what about viewing the encrypted balances? Well, we'll cover that in the next section, where we'll be adding viewing\nfunctionality to our contract, and see how we can utilize ",(0,a.jsx)(n.code,{children:"Permissions"})," to manage access to encrypted data."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var a=t(6540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);