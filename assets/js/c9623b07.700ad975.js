"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[5343],{6628:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var t=i(4848),s=i(8453);const a={sidebar_position:900,title:"\ud83d\udcaf Useful Tips",description:"Tidbits of wisdom for working with FHE"},r=void 0,o={id:"devdocs/Writing Smart Contracts/Useful-Tips",title:"\ud83d\udcaf Useful Tips",description:"Tidbits of wisdom for working with FHE",source:"@site/docs/devdocs/Writing Smart Contracts/Useful-Tips.md",sourceDirName:"devdocs/Writing Smart Contracts",slug:"/devdocs/Writing Smart Contracts/Useful-Tips",permalink:"/docs/devdocs/Writing Smart Contracts/Useful-Tips",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/tree/main/docs/devdocs/Writing Smart Contracts/Useful-Tips.md",tags:[],version:"current",sidebarPosition:900,frontMatter:{sidebar_position:900,title:"\ud83d\udcaf Useful Tips",description:"Tidbits of wisdom for working with FHE"},sidebar:"docsSidebar",previous:{title:"\ud83d\udd00 Parallel Decryptions",permalink:"/docs/devdocs/Writing Smart Contracts/Parallel-Decryptions"},next:{title:"\ud83d\udd25 Gas and Benchmarks",permalink:"/docs/devdocs/Writing Smart Contracts/Gas-and-Benchmarks"}},c={},l=[{value:"Trivial Encryption",id:"trivial-encryption",level:2},{value:"Default Value of a Euint",id:"default-value-of-a-euint",level:2},{value:"Re-encrypting a Value",id:"re-encrypting-a-value",level:2},{value:"FHE.req()",id:"fhereq",level:2},{value:"FHE.decrypt()",id:"fhedecrypt",level:2},{value:"Decryption \u2013 Best Practice",id:"decryption--best-practice",level:3},{value:"Performance and Gas Usage",id:"performance-and-gas-usage",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"trivial-encryption",children:"Trivial Encryption"}),"\n",(0,t.jsxs)(n.p,{children:["Casting a plaintext number to an encrypted one in a contract (i.e. ",(0,t.jsx)(n.code,{children:"FHE.asEuintX(plaintext_number)"}),") is called Trivial Encryption. Unlike ",(0,t.jsx)(n.a,{href:"/docs/devdocs/FhenixJS/Encryption",children:"normal FHE encryption"}),", trivial encryption is deterministic. This means that if you perform it more than once, the resulting ciphertext will be the same every time."]}),"\n",(0,t.jsxs)(n.p,{children:['Despite being obviously weaker than normal FHE encrypted numbers, Trivial Encryption can often be very useful. For example, when you\'re tallying votes in a contract; the tally for the option "Yes" may be encrypted, but everyone knows that you need to increment it by ',(0,t.jsx)(n.code,{children:"1"})," for every incoming vote. Meaning, you can do ",(0,t.jsx)(n.code,{children:"tally = tally + FHE.asEuint32(1)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Using trivially encrypted numbers is more efficient and will result in faster and cheaper execution - so it's beneficial to use them whenever possible ",(0,t.jsx)(n.strong,{children:"while being careful to not compromise your apps's security"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," to prevent improper use, Trivial Encryption is only available in contracts."]}),"\n",(0,t.jsx)(n.h2,{id:"default-value-of-a-euint",children:"Default Value of a Euint"}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.code,{children:"euintx"})," variable is not initialized, it is considered to be 0. Every FHE function that receives an uninitialized ",(0,t.jsx)(n.code,{children:"euintx"})," assumes that it is ",(0,t.jsx)(n.code,{children:"FHE.asEuintX(0)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"FHE.asEuintX(0)"})," is actually used quite often. Fhenix takes this frequent use into consideration and pre-calculates the values of ",(0,t.jsx)(n.code,{children:"FHE.asEuintX(0)"})," during node initialization. Therefore, when ",(0,t.jsx)(n.code,{children:"FHE.asEuintX(0)"})," is used during operation, the pre-calculated values are returned (which saves computing resources and gas)."]}),"\n",(0,t.jsx)(n.h2,{id:"re-encrypting-a-value",children:"Re-encrypting a Value"}),"\n",(0,t.jsx)(n.p,{children:"Re-encrypting a value is sometimes necessary in smart contracts. For example, consider a confidential voting system with four candidates. Each vote increases the respective tally (using FHE addition, which is a cryptographic operation). If one monitors the (public!) database keys representing these tallies, even though a tally value is encrypted, it's enough to notice a change in the value to deduce which option got voted for. One solution is to change all the values, regardless of the vote cast - so anyone monitoring would not be able to tell which option got voted for. But how do we do that?"}),"\n",(0,t.jsxs)(n.p,{children:["FHE encryption is non-deterministic, meaning that encrypting the same number twice (using non-trivial encryption) results in two different encrypted outputs. Similarly, a computation on an encrypted number, ",(0,t.jsx)(n.strong,{children:"even if the computations does not change the underlying plaintext value"}),", changes the ciphertext. Without decrypting the number, one would not be able to tell if it actually changed or not. We leverage this feature and cryptographically add 0 to all tallies that should not be changed using FHE.add. This operation re-encrypts those values (or - changes the ciphertext), resulting in new encrypted outputs in the database, effectively updating all keys without changing the actual tallies."]}),"\n",(0,t.jsx)(n.p,{children:"Example (simplified pseudo code):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"// This is bad\nt = getTallyToIncrement(userInput);\ntallies[t] = FHE.add(tallies[t], FHE.asEuint32(1));\n\n// This is good\nfor (int i = 0; i < len(tallies); i++) {\n    ebool b = toIncrement(userInput, i);\n    tallies[t] = FHE.add(tallies[t], b); // if `b` is true, this will translate to `tally + 1`, otherwise `tally + 0`\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"fhereq",children:"FHE.req()"}),"\n",(0,t.jsxs)(n.p,{children:["All ",(0,t.jsx)(n.code,{children:"FHE.req"})," operations are supported in both transactions (TXs) and queries. However, we strongly advise careful consideration before using these operations inside a transaction, because ",(0,t.jsx)(n.code,{children:"FHE.req"})," might expose the value of encrypted data. For example, if we send a transaction and monitor its gas usage, we can likely determine whether a ",(0,t.jsx)(n.code,{children:"FHE.req"})," condition was met and infer much about what the encrypted values represent."]}),"\n",(0,t.jsx)(n.p,{children:"Consider the following code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function f(euint8 a, euint8 b) public {\n    FHE.req(a.eq(b));\n    // Do some heavy logic\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," are not equal, the function will fail immediately and consumes much less gas compared to a situation in which ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," are equal. This means that monitoring gas usage can easily determine whether a and b are equal, potentially leaking confidential information without revealing the actual values."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Best Practice:"})," use ",(0,t.jsx)(n.code,{children:"FHE.req"})," only in view functions. For transactions, ",(0,t.jsx)(n.code,{children:"FHE.req"})," logic can be implemented using ",(0,t.jsx)(n.code,{children:"FHE.select"}),". This approach helps preserve confidentiality while achieving the desired functionality."]}),"\n",(0,t.jsx)(n.h2,{id:"fhedecrypt",children:"FHE.decrypt()"}),"\n",(0,t.jsxs)(n.p,{children:["The Fhenix implementation of Fully Homomorphic Encryption (FHE) intends to keep data encrypted throughout its entire lifecycle, while providing the capability to operate on the encrypted data. However, eventually decrypting data (",(0,t.jsx)(n.code,{children:"FHE.decrypt"}),") is crucial in most use cases."]}),"\n",(0,t.jsx)(n.p,{children:"Decrypting is a risky operation. You should always consider that a malicious node runner might have DMA (direct memory access) or any other way to read the process' memory. Always assume that a node runner can see what is the decrypted value while it is being executed (before it's committed to a block) and, for example, use it for MEV."}),"\n",(0,t.jsx)(n.h3,{id:"decryption--best-practice",children:"Decryption \u2013 Best Practice"}),"\n",(0,t.jsx)(n.p,{children:"Follow these guidelines to maintain data security and integrity when using FHE.decrypt:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"View functions"}),": preferably, decrypt in view functions only when possible, for example when the data is being accessed for read-only purposes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transactions"}),": use decryption in transactions only when you are absolutely certain that the data is no longer confidential. For instance, in a poker game application, during the roundup transaction, cards can be revealed without data leakage risk."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-and-gas-usage",children:"Performance and Gas Usage"}),"\n",(0,t.jsx)(n.p,{children:"Currently, Fhenix supports a large number of FHE operations. Some operations take much time to compute. Good examples of time-intensive operations are: Div, Mul, and Rem. Time increases depending on the value types being used (euint64 will take longer than euint32).\nWhen writing FHE code, Fhenix encourages using operations wisely, especially when choosing which operation to use."}),"\n",(0,t.jsxs)(n.p,{children:["For example, instead of ",(0,t.jsx)(n.code,{children:"ENCRYPTED_UINT_32 * FHE.asEuint32(2)"}),", it is preferable to use ",(0,t.jsx)(n.code,{children:"FHE.shl(ENCRYPTED_UINT_32, FHE.asEuint32(1))"}),".\nIn other cases, ",(0,t.jsx)(n.code,{children:"FHE.div(ENCRYPTED_UINT_32, FHE.asEuint32(2))"})," can be replaced by ",(0,t.jsx)(n.code,{children:"FHE.shr(ENCRYPTED_UINT_32, FHE.asEuint32(1))"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For more detailed benchmarks, refer to: ",(0,t.jsx)(n.a,{href:"./Gas-and-Benchmarks",children:"Gas and Benchmarks"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);