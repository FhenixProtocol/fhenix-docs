"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[3912],{9052:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var r=t(4848),s=t(8453),i=t(1470),a=t(9365);const o={sidebar_position:1,title:"Installation & Basics"},l=void 0,c={id:"devdocs/FhenixJS/Fhenix-JS",title:"Installation & Basics",description:"Overview",source:"@site/docs/devdocs/FhenixJS/Fhenix-JS.mdx",sourceDirName:"devdocs/FhenixJS",slug:"/devdocs/FhenixJS/Fhenix-JS",permalink:"/docs/nitrogen/devdocs/FhenixJS/Fhenix-JS",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/tree/main/docs/devdocs/FhenixJS/Fhenix-JS.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Installation & Basics"},sidebar:"docsSidebar",previous:{title:"Fhenix.JS",permalink:"/docs/nitrogen/category/fhenixjs"},next:{title:"Encryption",permalink:"/docs/nitrogen/devdocs/FhenixJS/Encryption"}},d={},u=[{value:"Overview",id:"overview",level:2},{value:"Mental Model",id:"mental-model",level:2},{value:"Adding to the User\u2019s Counter",id:"adding-to-the-users-counter",level:3},{value:"Retrieving the User\u2019s Counter",id:"retrieving-the-users-counter",level:3},{value:"Installation",id:"installation",level:2},{value:"Setup",id:"setup",level:2},{value:"Encrypting Input Data",id:"encrypting-input-data",level:2},{value:"Creating Permits",id:"creating-permits",level:2},{value:"Unsealing Data",id:"unsealing-data",level:2},{value:"End-to-End Example Explanation",id:"end-to-end-example-explanation",level:2},{value:"Troubleshoot",id:"troubleshoot",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Fhenix.js is a TypeScript package designed to enable seamless interaction between clients and the Fhenix blockchain. It is an essential component for engineers working with Fhenix-enabled smart contracts, as it facilitates the encryption and decryption processes required for secure data handling in decentralized applications (dApps). Fhenix.js ensures that data remains private throughout its journey from input to output in the blockchain ecosystem.\nFhenix-enabled contracts require three primary modifications to the client/frontend:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Encrypting Input Data: Before passing data to the smart contract, input must be encrypted to ensure its confidentiality. To read more about encrypted inputs, go ",(0,r.jsx)(n.a,{href:"/docs/nitrogen/devdocs/Writing%20Smart%20Contracts/User-Inputs",children:"here"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Creating Permits and Permissions: The client must generate permits and permissions that determine who can interact with or view the data. Read more about ",(0,r.jsx)(n.a,{href:"/docs/nitrogen/devdocs/Writing%20Smart%20Contracts/Permissions",children:"Permissions"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Unsealing Output Data: After the contract processes the data, the client must decrypt the output for it to be used or displayed. For more, refer to our page on ",(0,r.jsx)(n.a,{href:"/docs/nitrogen/devdocs/Writing%20Smart%20Contracts/Returning-Data",children:"Outputs"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Fhenix.js allows encryption to begin and end privately in a dApp, while FHE-enabled contracts do work on and with these encrypted values."}),"\n",(0,r.jsx)(n.h2,{id:"mental-model",children:"Mental Model"}),"\n",(0,r.jsxs)(n.p,{children:["To understand how ",(0,r.jsx)(n.strong,{children:"fhenix.js"})," fits into the Fhenix framework, we will create a simple mental model to show how data moves through Fhenix-powered dApps."]}),"\n",(0,r.jsxs)(n.p,{children:['Consider a smart contract called "',(0,r.jsx)(n.strong,{children:"Counter"}),'". Each user has an individual counter, and users increment and read their own counters with complete privacy. In this example, a ',(0,r.jsx)(n.strong,{children:"public key"})," is like a lock, and a ",(0,r.jsx)(n.strong,{children:"private key"})," is the corresponding key to unlock it."]}),"\n",(0,r.jsx)(n.h3,{id:"adding-to-the-users-counter",children:"Adding to the User\u2019s Counter"}),"\n",(0,r.jsxs)(n.p,{children:['When users want to add a value to their counter, say "5," they first place this value inside a sort-of "box". Using fhenix.js, this box is secured by locking it with Fhenix blockchain\u2019s ',(0,r.jsx)(n.strong,{children:"public key"}),' (encryption). The locked box is then sent to the smart contract. Thanks to Fully Homomorphic Encryption (FHE), Fhenix can perform mathematical operations directly on these sealed boxes\u2014without accessing the raw data inside. So, the user\'s encrypted value, "5," can be added to the user\u2019s encrypted counter while remaining private.']}),"\n",(0,r.jsx)(n.h3,{id:"retrieving-the-users-counter",children:"Retrieving the User\u2019s Counter"}),"\n",(0,r.jsx)(n.p,{children:"To retrieve the counter value, the user needs to read the data inside the box without breaking the encryption. Here\u2019s the clever part: the user sends a second \u201clock\u201d (their own public key) along with the request to read its data. This second lock is applied to the box (now the box has two locks). Fhenix can now remove its own lock (the blockchain\u2019s public key), leaving the box secured by only the user\u2019s public key. The box remains locked and the data remains private, but now only the user can open it using its private key."}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsx)(n.p,{children:"To get started with fhenix.js, you need to install it as a dependency in your JavaScript project. You can do this using npm (Node Package Manager) or Yarn. Open your terminal and navigate to your project's directory, then run the following:"}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsx)(a.A,{value:"yarn",label:"yarn",children:(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"bash yarn add fhenixjs "})})}),(0,r.jsx)(a.A,{value:"npm",label:"npm",children:(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"npm install fhenixjs"})})}),(0,r.jsx)(a.A,{value:"pnpm",label:"pnpm",children:(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"pnpm add fhenixjs"})})})]}),"\n",(0,r.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,r.jsxs)(n.p,{children:["To use ",(0,r.jsx)(n.strong,{children:"fhenix.js"})," for interacting with FHE-enabled Fhenix smart contracts, the ",(0,r.jsx)(n.code,{children:"FhenixClient"})," must be initialized. This client handles key operations such as encrypting input data, creating permits, and decrypting output data from the blockchain.\nFirst, the client must be initialized. Below is an example setup:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { FhenixClient } from "fhenixjs";\nimport { JsonRpcProvider } from "ethers";\n\n// initialize your web3 provider\nconst provider = new JsonRpcProvider("https://api.nitrogen.fhenix.zone");\n\n// initialize Fhenix Client\nconst client = new FhenixClient({ provider });\n\n'})}),"\n",(0,r.jsx)(n.h2,{id:"encrypting-input-data",children:"Encrypting Input Data"}),"\n",(0,r.jsxs)(n.p,{children:["This step secures the data before sending it to the smart contract. Remember--all data sent to a smart contract on a blockchain is inherently public, which means that anyone can see it. However, Fhenix operates differently. To maintain user confidentiality and protect sensitive input data, Fhenix utilizes ",(0,r.jsx)(n.strong,{children:"fhenix.js"})," to provide built-in encryption methods that must be applied before sending any data to an FHE-enabled contract (Learn more ",(0,r.jsx)(n.a,{href:"https://docs.fhenix.zone/docs/devdocs/FhenixJS/Encryption",children:"here"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"For example, if you want to send a value of \u201c5\u201d to a smart contract, you need to encrypt it before passing it along. Here\u2019s sample code for that process:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const value = 5;\nconst eValue = await client.encryptUint8(value);\n\n// Solidity FHE function (note inEuint8)\n// Counter.sol\n// function add(inEuint8 value) public;\n\n// Contract logic pseudocode\nethereum.send({\n  contract: "Counter",\n  functionName: "add",\n  args: [eValue]\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"FhenixClient"})," can expose encryption functions for inEuint8, inEuint256, inEbool, and inEaddress (this example used inEuint8)."]}),"\n",(0,r.jsx)(n.p,{children:"By encrypting user data before sending it to a contract, Fhenix ensures that data remains private throughout its lifecycle in the blockchain environment."}),"\n",(0,r.jsx)(n.h2,{id:"creating-permits",children:"Creating Permits"}),"\n",(0,r.jsxs)(n.p,{children:["After encryption, values can be passed into FHE-enabled smart contracts, and the contract can operate on this data securely, within its own logic. However, to ensure that only the respective user can view the processed (encrypted) data, ",(0,r.jsx)(n.strong,{children:"permissions"})," and ",(0,r.jsx)(n.strong,{children:"sealing"})," mechanisms are used. These ensure that data remains private and viewable exclusively by the user who owns it. Learn more at ",(0,r.jsx)(n.a,{href:"https://docs.fhenix.zone/docs/devdocs/Writing%20Smart%20Contracts/Permissions",children:"link"})," and ",(0,r.jsx)(n.a,{href:"https://docs.fhenix.zone/docs/devdocs/Writing%20Smart%20Contracts/Returning-Data",children:"link"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Permissions serve two main purposes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Verify User Identity"}),": They ensure that the data access request comes from the correct user by verifying that the message is signed with the user\u2019s private key."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sealing User Data"}),": They provide a ",(0,r.jsx)(n.strong,{children:"public key"}),' to "seal" the encrypted data, meaning it is encrypted in such a way that only the user holding the corresponding ',(0,r.jsx)(n.strong,{children:"private key"})," (stored securely on the user's client) can decrypt it later."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Fhenix uses ",(0,r.jsx)(n.strong,{children:"EIP712"}),", a widely used Ethereum standard for signing structured data. This means: first, a user must sign a permit in their wallet to authenticate themselves and authorize the creation of the permit; second, permits are stored locally in local storage and can be reused for future interactions with the same contract. Currently, each contract that the user interacts with requires its own unique permit (subject to change)."]}),"\n",(0,r.jsxs)(n.p,{children:["Permits are created with the ",(0,r.jsx)(n.code,{children:"FhenixClient"}),". Here's the code for this process:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Address of the contract to create the permit for:\nconst counterAddress = 0x....;\n\n// The permit is generated by the client\nconst permit = await client.generatePermit(counterAddress);\n\n// The permission to be sent to the contract is generated from the permit\nconst permission = client.extractPermitPermission(permit);\n\n// Counter.sol solidity\n// Example read function using Permissions\n// function getUserCounter(Permission calldata perm) public view onlySender(perm) returns (string memory) {\n//     return userCounter[msg.sender].seal(perm.publicKey);\n// }\n\n// dApp pseudocode\nconst result = await ethereum.read({\n  contract: "Counter",\n  functionName: "getUserCounter",\n  args: [permission]\n});\n// result -> sealed uint8 (see unsealing below)\n\n'})}),"\n",(0,r.jsx)(n.h2,{id:"unsealing-data",children:"Unsealing Data"}),"\n",(0,r.jsxs)(n.p,{children:["After encryption, the data can be securely processed by the contract and sealed with the user\u2019s ",(0,r.jsx)(n.strong,{children:"public key"})," (from their permit), and it is returned to the user when the user requests it. To access and interpret this data, the user must ",(0,r.jsx)(n.strong,{children:"unseal"})," it using their private key, which is securely stored on their device. The unsealing process is essential to ensure that only the intended user can view the final result."]}),"\n",(0,r.jsxs)(n.p,{children:["When the contract returns the encrypted data to the user, it remains sealed. This means the data is still encrypted with the user\u2019s ",(0,r.jsx)(n.strong,{children:"public key"})," and cannot be read until the corresponding ",(0,r.jsx)(n.strong,{children:"private key"})," is used to unlock it. ",(0,r.jsx)(n.strong,{children:"Fhenix.js"})," provides a simple method to handle this."]}),"\n",(0,r.jsx)(n.p,{children:"Here\u2019s example code to show how the unsealing process works:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const counterAddress = 0x....;\n\nconst result = await ethereum.read({\n  contract: "Counter",\n  functionName: "getUserCounter",\n  args: [permission]\n});\n\nconst unsealed = client.unseal(counterAddress, result);\n\n'})}),"\n",(0,r.jsx)(n.h2,{id:"end-to-end-example-explanation",children:"End-to-End Example Explanation"}),"\n",(0,r.jsxs)(n.p,{children:["This example demonstrates a full interaction between a dApp and an FHE-enabled smart contract using the ",(0,r.jsx)(n.code,{children:"FhenixClient"}),". It walks through how to set up the client, encrypt data, send it to the contract, create a permit for accessing sealed data, and finally unseal the returned data for the user."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// == Setup ==\n\nimport { FhenixClient } from \'fhenixjs\';\nimport { JsonRpcProvider } from \'ethers\'\n\nconst provider = new JsonRpcProvider(\'https://api.helium.fhenix.zone\');\nconst client = new FhenixClient({provider});\n\n// == Input ==\n\nconst value = 5;\nconst eValue = await client.encryptUint8(value);\n\n// pseudocode\nawait ethereum.send({\n  contract: "Counter",\n  functionName: "add",\n  args: [eValue]\n});\n\n// == Permit / Permission ==\n\nconst counterAddress = 0x....;\nconst permit = await client.generatePermit(counterAddress);\nconst permission = client.extractPermitPermission(permit);\n\n// pseudocode\nconst result = await ethereum.read({\n  contract: "Counter",\n  functionName: "getUserCounter",\n  args: [permission]\n});\n\n// == Unseal ==\n\nconst unsealed = client.unseal(counterAddress, result);\n\n'})}),"\n",(0,r.jsx)(n.h2,{id:"troubleshoot",children:"Troubleshoot"}),"\n",(0,r.jsx)(n.p,{children:"a. Getting a wasm error when using Fhenix.js with Node.js:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"\nnode:internal/modules/esm/get_format:160\n  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);\n        ^\n\nTypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension \".wasm\" for .../node_modules/.pnpm/fhenixjs@0.4.0/node_modules/fhenixjs/lib/esm/sdk/fhe/tfhe_bg.wasm\n    at Object.getFileProtocolModuleFormat [as file:] (node:internal/modules/esm/get_format:160:9)\n    at defaultGetFormat (node:internal/modules/esm/get_format:203:36)\n    at defaultLoad (node:internal/modules/esm/load:143:22)\n    at async ModuleLoader.load (node:internal/modules/esm/loader:396:7)\n    at async ModuleLoader.moduleProvider (node:internal/modules/esm/loader:278:45) {\n  code: 'ERR_UNKNOWN_FILE_EXTENSION'\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"You need to run your node application with experimental-modules flag :"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"node --experimental-modules --experimental-wasm-modules your_file_here.js\n"})}),"\n",(0,r.jsx)(n.p,{children:"b. If you are using Vue / Nuxt 3, you might get an error about loading the tfhe_bg.wasm."}),"\n",(0,r.jsx)(n.p,{children:"You can try to load the esm file:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { FhenixClient } from "~/node_modules/fhenixjs/dist/fhenix.esm.js";\n'})}),"\n",(0,r.jsx)(n.p,{children:"or use the fhenix.umd.min.js file inside the dist folder."})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>a});t(6540);var r=t(4164);const s={tabItem:"tabItem_Ymn6"};var i=t(4848);function a(e){let{children:n,hidden:t,className:a}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,a),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>w});var r=t(6540),s=t(4164),i=t(3104),a=t(6347),o=t(205),l=t(7485),c=t(1682),d=t(679);function u(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}))}(t);return function(e){const n=(0,c.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const s=(0,a.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l.aZ)(i),(0,r.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(s.location.search);n.set(i,e),s.replace({...s.location,search:n.toString()})}),[i,s])]}function x(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,i=h(e),[a,l]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[c,u]=m({queryString:t,groupId:s}),[x,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,i]=(0,d.Dv)(t);return[s,(0,r.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:s}),f=(()=>{const e=c??x;return p({value:e,tabValues:i})?e:null})();(0,o.A)((()=>{f&&l(f)}),[f]);return{selectedValue:a,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),g(e)}),[u,g,i]),tabValues:i}}var g=t(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=t(4848);function b(e){let{className:n,block:t,selectedValue:r,selectValue:a,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),d=e=>{const n=e.currentTarget,t=l.indexOf(n),s=o[t].value;s!==r&&(c(n),a(s))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>l.push(e),onKeyDown:u,onClick:d,...i,className:(0,s.A)("tabs__item",f.tabItem,i?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function y(e){let{lazy:n,children:t,selectedValue:s}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function j(e){const n=x(e);return(0,v.jsxs)("div",{className:(0,s.A)("tabs-container",f.tabList),children:[(0,v.jsx)(b,{...n,...e}),(0,v.jsx)(y,{...n,...e})]})}function w(e){const n=(0,g.A)();return(0,v.jsx)(j,{...e,children:u(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);