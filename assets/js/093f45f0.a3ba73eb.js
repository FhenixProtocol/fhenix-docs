"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[7966],{7619:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var o=t(4848),r=t(8453);const i={sidebar_position:300,title:"\ud83d\udd00 Parallel Decryptions"},a=void 0,s={id:"devdocs/Writing Smart Contracts/Parallel-Decryptions",title:"\ud83d\udd00 Parallel Decryptions",description:"In Fully Homomorphic Encryption (FHE) schemes, decryption can be slow and computationally expensive, especially when using a Threshold Network. Additionally, since a Threshold Network functions as a sort of network in itself and serves as an oracle for the main blockchain, it cannot perform decryption synchronously, since decryptions may take too long to be practical or the Threshold Network might be busy or unavailable.",source:"@site/docs/devdocs/Writing Smart Contracts/Parallel-Decryptions.md",sourceDirName:"devdocs/Writing Smart Contracts",slug:"/devdocs/Writing Smart Contracts/Parallel-Decryptions",permalink:"/docs/nitrogen/devdocs/Writing Smart Contracts/Parallel-Decryptions",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/tree/main/docs/devdocs/Writing Smart Contracts/Parallel-Decryptions.md",tags:[],version:"current",sidebarPosition:300,frontMatter:{sidebar_position:300,title:"\ud83d\udd00 Parallel Decryptions"},sidebar:"docsSidebar",previous:{title:"\ud83d\udee1\ufe0f Security Zones",permalink:"/docs/nitrogen/devdocs/Writing Smart Contracts/Security-Zones"},next:{title:"\ud83d\udcaf Useful Tips",permalink:"/docs/nitrogen/devdocs/Writing Smart Contracts/Useful-Tips"}},c={},l=[{value:"Better developer and user experience",id:"better-developer-and-user-experience",level:3},{value:"In depth",id:"in-depth",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["In Fully Homomorphic Encryption (FHE) schemes, decryption can be slow and computationally expensive, especially when using a ",(0,o.jsx)(n.a,{href:"/docs/nitrogen/devdocs/Fhenix%20Testnet/Threshold-Network",children:"Threshold Network"}),". Additionally, since a Threshold Network functions as a sort of network in itself and serves as an oracle for the main blockchain, it cannot perform decryption synchronously, since decryptions may take too long to be practical or the Threshold Network might be busy or unavailable.\nTo address this issue, Nitrogen introduces Parallel Decryptions. This feature performs asynchronous decryption while providing the experience of synchronous decryption. Instead of using callbacks, as in traditional oracle-based protocols, Fhenix allows developers to write code normally, without needing to be concerned that a decryption request is being sent to an external component."]}),"\n",(0,o.jsx)(n.h3,{id:"better-developer-and-user-experience",children:"Better developer and user experience"}),"\n",(0,o.jsx)(n.p,{children:"This approach improves the whole experience in two key ways:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Developers can write clean, cohesive code without worrying about asynchronous decryption."}),"\n",(0,o.jsx)(n.li,{children:"Users and dApps avoid the need for multiple transactions to handle decryption callbacks."}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-solidity",children:"  euint32 encrypted; \n  uint32  decrypted;\n\n  function decryptInFhenix() public {\n    // Beginning of function logic ..\n\n    decrypted = FHE.decrypt(encrypted);\n\n    // Continue of function logic..\n  }\n\n  // -------- Otherwise.. --------\n  // (*simplified* example of callback-based decryption)\n\n  function requestDecrypt() public {\n    // Beginning of function logic ..\n    FHE.decryptWithCallback(encrypted);\n  }\n\n  // This function will be called after some time in a different TX\n  function receiveDecryptCallback(uint32 result) public {\n    decrypted = result;\n    // Continue of function logic..\n  }\n"})}),"\n",(0,o.jsx)(n.p,{children:"As shown in the example above, Fhenix's parallel decryption approach allows for clean, straightforward code that reads like normal synchronous operations. Developers can write their business logic in a natural flow, with decryption seamlessly integrated into their functions. This makes the code more maintainable and easier to understand, while Fhenix handles all the complexity of asynchronous decryption behind the scenes."}),"\n",(0,o.jsx)(n.h3,{id:"in-depth",children:"In depth"}),"\n",(0,o.jsx)(n.p,{children:"Behind the scenes, decryption requests are detected in transactions and sent to the appropriate decrypting party (whether Threshold Network or local decryptor). While these decryption requests are processed, the transactions are pushed to a special queue (a sort of tx-mempool). After all the decryption requests for a transaction are completed, the transaction is included in a block and executed."}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"Since Fhenix is an L2 solution with a sequencer, no traditional mempool is in place. As a result, there may be a slight delay before the transaction is included and executed in a block, potentially leading to a timeout of the original transaction (tx) receipt. To handle this, periodically query the tx hash in your UI."})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"// Example of handling parallel decryption transactions in a frontend application\nasync function handleDecryptTransaction(contract, methodName, ...args) {\n  try {\n    // Send the transaction that includes decryption\n    const tx = await contract[methodName](...args);\n    \n    // Get initial transaction receipt\n    let receipt = await tx.wait();\n    \n    // If the receipt times out, periodically check the transaction status\n    if (!receipt || receipt.status === 'pending') {\n      receipt = await pollTransactionStatus(tx.hash);\n    }\n    \n    return receipt;\n  } catch (error) {\n    console.error('Transaction failed:', error);\n    throw error;\n  }\n}\n\n// Helper function to poll transaction status\nasync function pollTransactionStatus(txHash, maxAttempts = 20) {\n  let attempts = 0;\n  \n  while (attempts < maxAttempts) {\n    const receipt = await provider.getTransactionReceipt(txHash);\n    \n    if (receipt && receipt.status === 1) {\n      return receipt;\n    }\n    \n    // Wait 3 seconds before next attempt\n    await new Promise(resolve => setTimeout(resolve, 3000));\n    attempts++;\n  }\n  \n  throw new Error('Transaction timeout: Decryption taking longer than expected');\n}\n\n// Usage example\nconst contract = new ethers.Contract(address, abi, signer);\n\ntry {\n  const receipt = await handleDecryptTransaction(\n    contract,\n    'decryptInFhenix'\n  );\n  console.log('Transaction completed:', receipt);\n} catch (error) {\n  console.log('Failed to process decryption:', error);\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(6540);const r={},i=o.createContext(r);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);