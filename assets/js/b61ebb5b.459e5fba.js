"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[1412],{2342:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=t(4848),a=t(8453);const o={sidebar_position:3,title:"\ud83d\udd10 Encryption Schema"},s=void 0,r={id:"devdocs/Fhenix Testnet/Details/Encryption-Schema",title:"\ud83d\udd10 Encryption Schema",description:"In this section we will describe the encryption schema used in Fhenix. While the network itself is Schema agnostic - i.e. it can support any encryption schema - the current default schema is TFHE.",source:"@site/docs/devdocs/Fhenix Testnet/Details/Encryption-Schema.md",sourceDirName:"devdocs/Fhenix Testnet/Details",slug:"/devdocs/Fhenix Testnet/Details/Encryption-Schema",permalink:"/docs/devdocs/Fhenix Testnet/Details/Encryption-Schema",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/tree/main/docs/devdocs/Fhenix Testnet/Details/Encryption-Schema.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"\ud83d\udd10 Encryption Schema"},sidebar:"docsSidebar",previous:{title:"\ud83d\udd00 Fhenix Differences For Developers",permalink:"/docs/devdocs/Fhenix Testnet/Details/Fhenix-Differences"},next:{title:"Changelog",permalink:"/docs/devdocs/Fhenix Testnet/Details/Changelog"}},c={},l=[{value:"FHE over the Torus (TFHE)",id:"fhe-over-the-torus-tfhe",level:2},{value:"Cheon-Kim-Kim-Song (CKKS)",id:"cheon-kim-kim-song-ckks",level:3},{value:"Brakerski-Gentry-Vaikuntanathan (BGV)",id:"brakerski-gentry-vaikuntanathan-bgv",level:3}];function h(e){const n={h2:"h2",h3:"h3",p:"p",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"In this section we will describe the encryption schema used in Fhenix. While the network itself is Schema agnostic - i.e. it can support any encryption schema - the current default schema is TFHE."}),"\n",(0,i.jsx)(n.h2,{id:"fhe-over-the-torus-tfhe",children:"FHE over the Torus (TFHE)"}),"\n",(0,i.jsx)(n.p,{children:"FHE over the Torus (TFHE) represents an advanced FHE scheme that offers notable improvements over traditional FHE technologies."}),"\n",(0,i.jsx)(n.p,{children:"Blockchains basically deal with integer operations, whether handling large volumes of cryptocurrency transactions, managing smart contract states, or updating block indices. All these essential operations are based on integers. TFHE's efficient processing of computations is performed on integers in their encrypted form and thus provides significant added value."}),"\n",(0,i.jsx)(n.p,{children:"Furthermore, most blockchains operate on a consensus mechanism that involves numerous complex integer-based computations. TFHE's ability to handle these operations quickly and efficiently increases overall blockchain performance and reduces computational bottlenecks. The benefit of this efficiency becomes even more crucial as blockchains scale, resulting in increased transaction volume and smart contract complexity."}),"\n",(0,i.jsx)(n.p,{children:"TFHE offers an excellent, viable encryption solution for maintaining privacy and optimizing performance of blockchain technologies."}),"\n",(0,i.jsx)(n.p,{children:"In particular, TFHE may be a good choice due to its fast bootstrapping and relatively small bootstrapping key. Another significant feature of the TFHE scheme is its programmable bootstrapping technique, which enables evaluating a univariate function while simultaneously reducing noise."}),"\n",(0,i.jsx)(n.h3,{id:"cheon-kim-kim-song-ckks",children:"Cheon-Kim-Kim-Song (CKKS)"}),"\n",(0,i.jsx)(n.p,{children:"The Cheon-Kim-Kim-Song (CKKS) encryption scheme is specially tailored for handling arithmetic on complex numbers, making it uniquely suited for applications requiring calculations on fractional numbers or dealing with large datasets that include non-integer values. This makes CKKS an interesting choice for blockchain applications that need to process statistical data or perform financial calculations involving decimals, such as automated pricing models or complex financial derivatives within smart contracts."}),"\n",(0,i.jsx)(n.p,{children:"CKKS allows for approximate arithmetic on encrypted data, which can be a significant advantage when exact precision is not critical but speed and efficiency are. In the context of blockchains, this means that CKKS can be used to efficiently perform encrypted calculations on transaction amounts, exchange rates, and other financial metrics without decrypting them, thus preserving privacy while ensuring that the blockchain operates swiftly and scales effectively."}),"\n",(0,i.jsx)(n.h3,{id:"brakerski-gentry-vaikuntanathan-bgv",children:"Brakerski-Gentry-Vaikuntanathan (BGV)"}),"\n",(0,i.jsx)(n.p,{children:"The Brakerski-Gentry-Vaikuntanathan (BGV) scheme is known for its robustness and the ability to perform modular arithmetic operations on encrypted integers. BGV supports both addition and multiplication of ciphertexts. BGV is suitable for working with finite fields in modular exact arithmetic. However, its bootstrapping is slow compared to TFHE and CKKS, making it less ideal for circuits requiring frequent bootstrapping (i.e., circuits with large multiplicative depth) or for implementing non-linear functions. On the other hand, BGV supports NTT and CRT packing, making it a good choice for circuits with small multiplicative depth, particularly in applications that require processing large amounts of data."}),"\n",(0,i.jsx)(n.p,{children:"BGV's ability to handle certain types of computations efficiently may help maintaining overall performance and reduce computational bottlenecks."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(6540);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);