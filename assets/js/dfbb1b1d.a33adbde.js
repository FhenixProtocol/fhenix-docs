"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[3127],{2497:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>r,metadata:()=>a,toc:()=>h});var n=t(4848),o=t(8453);const r={sidebar_position:4,title:"\ud83e\uddee FHE Schemes Overview"},s=void 0,a={id:"devdocs/Fhenix Testnet/FHE-Overview",title:"\ud83e\uddee FHE Schemes Overview",description:"Fully Homomorphic Encryption (FHE) schemes are divided into three generations, each designed for different types of applications.",source:"@site/versioned_docs/version-Helium/devdocs/Fhenix Testnet/FHE-Overview.md",sourceDirName:"devdocs/Fhenix Testnet",slug:"/devdocs/Fhenix Testnet/FHE-Overview",permalink:"/docs/helium/devdocs/Fhenix Testnet/FHE-Overview",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/tree/main/versioned_docs/version-Helium/devdocs/Fhenix Testnet/FHE-Overview.md",tags:[],version:"Helium",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"\ud83e\uddee FHE Schemes Overview"},sidebar:"docsSidebar",previous:{title:"\ud83e\udd32 3rd party Integrations",permalink:"/docs/helium/devdocs/Fhenix Testnet/Integration"},next:{title:"Details",permalink:"/docs/helium/category/details"}},c={},h=[{value:"First Generation - Integer Arithmetic",id:"first-generation---integer-arithmetic",level:2},{value:"BGV Scheme",id:"bgv-scheme",level:3},{value:"Second Generation - Binary Operations",id:"second-generation---binary-operations",level:2},{value:"GSW Scheme",id:"gsw-scheme",level:3},{value:"FHEW Scheme",id:"fhew-scheme",level:3},{value:"TFHE Scheme",id:"tfhe-scheme",level:3},{value:"Third Generation - Approximate Number Arithmetic",id:"third-generation---approximate-number-arithmetic",level:2},{value:"CKKS Scheme",id:"ckks-scheme",level:3}];function d(e){const i={h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.p,{children:"Fully Homomorphic Encryption (FHE) schemes are divided into three generations, each designed for different types of applications."}),"\n",(0,n.jsx)(i.p,{children:"Each of these generations relies on solving complex problems like Learning with Errors (LWE) and its generalization Ring LWE (RLWE) to ensure security."}),"\n",(0,n.jsx)(i.p,{children:"We believe that understanding the advantages and disadvantages of each scheme will be important in being able to provide developers with the right tool for the application that they are trying to create."}),"\n",(0,n.jsx)(i.h2,{id:"first-generation---integer-arithmetic",children:"First Generation - Integer Arithmetic"}),"\n",(0,n.jsx)(i.h3,{id:"bgv-scheme",children:"BGV Scheme"}),"\n",(0,n.jsx)(i.p,{children:'The BGV scheme was the first practical, leveled homomorphic encryption method. It introduced a technique called "packing," allowing multiple plaintexts to be encrypted into a single ciphertext, making it efficient in handling multiple data points simultaneously (like SIMD in processors). It avoided the need for bootstrapping, although it also included a bootstrapping option to upgrade to a fully homomorphic scheme.'}),"\n",(0,n.jsx)(i.h2,{id:"second-generation---binary-operations",children:"Second Generation - Binary Operations"}),"\n",(0,n.jsx)(i.h3,{id:"gsw-scheme",children:"GSW Scheme"}),"\n",(0,n.jsx)(i.p,{children:'The GSW scheme introduces a unique approach for performing homomorphic operations called the "approximate eigenvector method." This method eliminates the need for "modulus switching" and "key switching." Instead, it uses multiplication via tensoring, which is later formalized as using a "gadget matrix." This approach significantly reduces error growth, but it does result in larger ciphertexts and higher computational costs. Due to these drawbacks, computations are limited to a binary message space. There is also an RLWE version of this scheme.'}),"\n",(0,n.jsx)(i.h3,{id:"fhew-scheme",children:"FHEW Scheme"}),"\n",(0,n.jsx)(i.p,{children:"The FHEW scheme is an optimized version of the GSW scheme, focusing on bootstrapping efficiency. It treats decryption as an arithmetic function rather than a boolean circuit. This RLWE variant incorporates several optimizations, making GSW-based bootstrapping faster than the BGV scheme. Key improvements include:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"Restricting computations to a binary message space and using a NAND gate for homomorphic operations."}),"\n",(0,n.jsx)(i.li,{children:"Enabling the evaluation of arbitrary functions via lookup tables during bootstrapping, known as \u201cprogrammable bootstrapping.\u201d"}),"\n",(0,n.jsx)(i.li,{children:"Utilizing efficient Fast Fourier Transform (FFT) methods for faster computations."}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"tfhe-scheme",children:"TFHE Scheme"}),"\n",(0,n.jsx)(i.p,{children:'This scheme uses "Blind Rotation" to enable fast bootstrapping, which is the process of refreshing a ciphertext to prevent error accumulation from making it unusable.\nIt involves two layers of encryption: a basic Learning with Errors (LWE) encryption and a special ring-based encryption for secure and efficient computation.\nThe TFHE scheme builds on FHEW techniques and employs methods like "modulus switching" and "key switching" for improved performance.'}),"\n",(0,n.jsx)(i.h2,{id:"third-generation---approximate-number-arithmetic",children:"Third Generation - Approximate Number Arithmetic"}),"\n",(0,n.jsx)(i.h3,{id:"ckks-scheme",children:"CKKS Scheme"}),"\n",(0,n.jsx)(i.p,{children:'CKKS introduces an innovative way to map real (or complex) numbers for encryption.\nIt includes a "rescaling" technique to manage noise during homomorphic computations, reducing ciphertext size while preserving most of the precision.\nOriginally a leveled scheme, it later incorporated efficient bootstrapping to become fully homomorphic and added support for packed ciphertexts.'})]})}function l(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>s,x:()=>a});var n=t(6540);const o={},r=n.createContext(o);function s(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);