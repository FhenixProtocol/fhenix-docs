"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[5160],{4348:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=t(5893),o=t(1151);const s={},r="Utility Contracts",a={id:"devdocs/Solidity API/Utilities",title:"Utility Contracts",description:"Encrypted Address",source:"@site/docs/devdocs/Solidity API/Utilities.md",sourceDirName:"devdocs/Solidity API",slug:"/devdocs/Solidity API/Utilities",permalink:"/fhenix-docs/docs/devdocs/Solidity API/Utilities",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/main/docs/devdocs/Solidity API/Utilities.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Permissioned.Sol Contract",permalink:"/fhenix-docs/docs/devdocs/Solidity API/Permissioned"},next:{title:"\ud83c\udfa7 Fhenix Encryption UI",permalink:"/fhenix-docs/docs/devdocs/Tools and Utilities/Fhenix-Encryption-UI"}},d={},c=[{value:"Encrypted Address",id:"encrypted-address",level:4},{value:"Random Number",id:"random-number",level:4}];function l(e){const n={code:"code",h1:"h1",h4:"h4",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"utility-contracts",children:"Utility Contracts"}),"\n",(0,i.jsx)(n.h4,{id:"encrypted-address",children:"Encrypted Address"}),"\n",(0,i.jsxs)(n.p,{children:["Encrypting an address is not an easy task as we currently only support encrypted uint32s (4 bytes) and address are formed out of 20 bytes.\nWe created a tool that implements ",(0,i.jsx)(n.code,{children:"Eaddress"})," which is formed by 5 uint32s.\nThis utility allows you to do some operations on encrypted addresses.\nThe tool can be imported from: TBD\nAn example of how to use the tool can be found it: TBD"]}),"\n",(0,i.jsx)(n.h4,{id:"random-number",children:"Random Number"}),"\n",(0,i.jsx)(n.p,{children:"Confidentiality is a crucial step in order to achieve on-chain randomness. Fhenix, as a chain that implements confidentiality, is a great space to implement and use on-chain random numbers and this is part of our roadmap.\nWe know that there are some #BUIDLers that are planning to implement dapps that leverage both confidentiality and random numbers so until we will have on-chain true random, we are suggesting to use the following implementation as a MOCKUP.\nPLEASE NOTE THAT THIS RANDOM NUMBER IS VERY PREDICTABLE AND CAN'T BE REALLY TRUSTED"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"library RandomMock {\n    function getFakeRandom() internal returns (uint256) {\n        uint blockNumber = block.number;\n        uint256 blockHash = uint256(blockhash(blockNumber));\n\n        return blockHash;\n    }\n\n    function getFakeRandomU8() public view returns (euint8) {\n        uint8 blockHash = uint8(getFakeRandom());\n        return FHE.asEuint8(blockHash);\n    }\n\n    function getFakeRandomU16() public view returns (euint16) {\n        uint16 blockHash = uint16(getFakeRandom());\n        return FHE.asEuint16(blockHash);\n    }\n\n    function getFakeRandomU32() public view returns (euint32) {\n        uint32 blockHash = uint32(getFakeRandom());\n        return FHE.asEuint32(blockHash);\n    }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>r});var i=t(7294);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);