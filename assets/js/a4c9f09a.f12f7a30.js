"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[792],{6716:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>d,default:()=>a,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var s=r(5893),n=r(1151);const i={},d="Supported Types and Operations",c={id:"Writing Smart Contracts/Types-and-Operators",title:"Supported Types and Operations",description:"The library exposes utility functions for FHE operations. The goal of the library is to provide a seamless developer experience for writing smart contracts that can operate on confidential data.",source:"@site/docs/Writing Smart Contracts/Types-and-Operators.md",sourceDirName:"Writing Smart Contracts",slug:"/Writing Smart Contracts/Types-and-Operators",permalink:"/docs/Writing Smart Contracts/Types-and-Operators",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/main/docs/Writing Smart Contracts/Types-and-Operators.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Select vs If...else",permalink:"/docs/Writing Smart Contracts/Select"},next:{title:"Handling Encrypted Inputs",permalink:"/docs/Writing Smart Contracts/User-Inputs"}},h={},l=[{value:"Types",id:"types",level:2},{value:"Operations",id:"operations",level:2}];function o(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"supported-types-and-operations",children:"Supported Types and Operations"}),"\n",(0,s.jsx)(t.p,{children:"The library exposes utility functions for FHE operations. The goal of the library is to provide a seamless developer experience for writing smart contracts that can operate on confidential data."}),"\n",(0,s.jsx)(t.h2,{id:"types",children:"Types"}),"\n",(0,s.jsx)(t.p,{children:"The library provides a type system that is checked both at compile time and at run time. The structure and operations related to these types are described in this sections."}),"\n",(0,s.jsx)(t.p,{children:"We currently support encrypted integers of bit length up to 32 bits."}),"\n",(0,s.jsxs)(t.p,{children:['These encrypted integers behave as much as possible as Solidity\'s integer types. However, behaviour such as "revert on overflow" is not supported as this would leak some information of the encrypted integers. Therefore, arithmetic on ',(0,s.jsx)(t.code,{children:"euint"})," types is ",(0,s.jsx)(t.a,{href:"https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic",children:"unchecked"}),", i.e. there is wrap-around on overlow."]}),"\n",(0,s.jsxs)(t.p,{children:["In the back-end, encrypted integers are FHE ciphertexts. The library abstracts away the ciphertexts and presents pointers to ciphertexts, or ciphertext handles, to the smart contract developer. The ",(0,s.jsx)(t.code,{children:"euint"})," types are ",(0,s.jsx)(t.em,{children:"wrappers"})," over these handles."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"name"}),(0,s.jsx)(t.th,{children:"Bit Size"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"euint8"}),(0,s.jsx)(t.td,{children:"8"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"euint16"}),(0,s.jsx)(t.td,{children:"16"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"euint32"}),(0,s.jsx)(t.td,{children:"32"})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"operations",children:"Operations"}),"\n",(0,s.jsx)(t.p,{children:"Fhenix exposes utility functions for operations on FHE ciphertexts. The list of supported operations is presented below."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"name"}),(0,s.jsx)(t.th,{children:"FHE.sol function"}),(0,s.jsx)(t.th,{children:"Operator"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Addition"}),(0,s.jsx)(t.td,{children:"add"}),(0,s.jsx)(t.td,{children:"+"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Subtraction"}),(0,s.jsx)(t.td,{children:"sub"}),(0,s.jsx)(t.td,{children:"-"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Multiplication"}),(0,s.jsx)(t.td,{children:"mul"}),(0,s.jsx)(t.td,{children:"*"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Bitwise And"}),(0,s.jsx)(t.td,{children:"and"}),(0,s.jsx)(t.td,{children:"&"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Bitwise Or"}),(0,s.jsx)(t.td,{children:"or"}),(0,s.jsx)(t.td,{children:"|"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Bitwise Xor"}),(0,s.jsx)(t.td,{children:"xor"}),(0,s.jsx)(t.td,{children:"^"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Shift Right"}),(0,s.jsx)(t.td,{children:"shr"}),(0,s.jsx)(t.td,{children:">>"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Shift Left"}),(0,s.jsx)(t.td,{children:"shl"}),(0,s.jsx)(t.td,{children:"<<"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Equal"}),(0,s.jsx)(t.td,{children:"eq"}),(0,s.jsx)(t.td,{children:"n/a"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Not equal"}),(0,s.jsx)(t.td,{children:"ne"}),(0,s.jsx)(t.td,{children:"n/a"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Greater than or equal"}),(0,s.jsx)(t.td,{children:"gte"}),(0,s.jsx)(t.td,{children:"n/a"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Greater than"}),(0,s.jsx)(t.td,{children:"gt"}),(0,s.jsx)(t.td,{children:"n/a"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Less than or equal"}),(0,s.jsx)(t.td,{children:"lte"}),(0,s.jsx)(t.td,{children:"n/a"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Less than"}),(0,s.jsx)(t.td,{children:"lt"}),(0,s.jsx)(t.td,{children:"n/a"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Min"}),(0,s.jsx)(t.td,{children:"min"}),(0,s.jsx)(t.td,{children:"n/a"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Max"}),(0,s.jsx)(t.td,{children:"max"}),(0,s.jsx)(t.td,{children:"n/a"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Negative"}),(0,s.jsx)(t.td,{children:"neg"}),(0,s.jsx)(t.td,{children:"n/a"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Not"}),(0,s.jsx)(t.td,{children:"not"}),(0,s.jsx)(t.td,{children:"n/a"})]})]})]})]})}function a(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>c,a:()=>d});var s=r(7294);const n={},i=s.createContext(n);function d(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:d(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);