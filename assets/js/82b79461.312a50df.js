"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[1264],{9601:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var s=n(5893),i=n(1151);const a={},o="Permits & Access Control",r={id:"devdocs/Writing Smart Contracts/Access-Control",title:"Permits & Access Control",description:"In a Fully Homomorphic Encryption (FHE) context, data stored in the contract's storage is encrypted.",source:"@site/docs/devdocs/Writing Smart Contracts/Access-Control.md",sourceDirName:"devdocs/Writing Smart Contracts",slug:"/devdocs/Writing Smart Contracts/Access-Control",permalink:"/fhenix-docs/docs/devdocs/Writing Smart Contracts/Access-Control",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/main/docs/devdocs/Writing Smart Contracts/Access-Control.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Translate your site",permalink:"/fhenix-docs/docs/devdocs/Tutorial/tutorial-extras/translate-your-site"},next:{title:"Converting Between Types",permalink:"/fhenix-docs/docs/devdocs/Writing Smart Contracts/Converting-between-Types"}},c={},d=[{value:"Permits",id:"permits",level:2},{value:"Basic Access Control Using EIP712",id:"basic-access-control-using-eip712",level:4},{value:"Advanced Access Control",id:"advanced-access-control",level:4},{value:"Standardization",id:"standardization",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"permits--access-control",children:"Permits & Access Control"}),"\n",(0,s.jsxs)(t.p,{children:["In a Fully Homomorphic Encryption (FHE) context, data stored in the contract's storage is encrypted.\nTherefore, granting selective access to data becomes an essential part of access control.\nThis is done via the ",(0,s.jsx)(t.code,{children:"sealoutput"})," function, which seals the data in a manner that only the intended\nrecipient can decrypt and view it (or the ",(0,s.jsx)(t.code,{children:"decrypt"})," function, for less sensitive data). This approach ensures that\nencrypted data remains confidential and only accessible to authorized users."]}),"\n",(0,s.jsx)(t.p,{children:"Usually, Solidity contracts will expose their data using View functions.\nHowever, in the context of permissioned data this is challenging for us since view functions do not come\nwith any kind of mechanism to allow the contract to cryptographically verify that the caller is who he says he is -\nin the case of transactions this is done by verifying the signature on the data."}),"\n",(0,s.jsx)(t.p,{children:"This means that we have to create mechanisms that enable the contract to determine who can access the data and who can't."}),"\n",(0,s.jsx)(t.h2,{id:"permits",children:"Permits"}),"\n",(0,s.jsx)(t.p,{children:"Permits are a mechanism that allows the contract to cryptographically verify that the caller is who he says he is."}),"\n",(0,s.jsx)(t.p,{children:"Simply, they are a signed message that contains the caller's public key, which the contract can then use to verify that the caller is who he says he is."}),"\n",(0,s.jsx)(t.h4,{id:"basic-access-control-using-eip712",children:"Basic Access Control Using EIP712"}),"\n",(0,s.jsx)(t.p,{children:"Out-of-the-box, Fhenix Solidity libraries come with a basic access control scheme. This helps contracts perform a basic check for ownership of an account."}),"\n",(0,s.jsx)(t.p,{children:"To confirm whether the recipient is authorized, EIP712 signatures are employed. EIP712 is a standard for Ethereum signed messages that makes it easier to understand the information being signed. This allows us to verify that the signer of a given piece of data is the owner of the account they claim to be."}),"\n",(0,s.jsx)(t.admonition,{title:"Did You Know?",type:"tip",children:(0,s.jsx)(t.p,{children:"When signing EIP712 typed data, wallets such as MetaMask provide a more transparent, safe interface for users to understand what they are signing"})}),"\n",(0,s.jsx)(t.p,{children:"Let's see this concept in action using an example. In an encrypted ERC20 token contract, a user would want to query their token balance. Since the balance is stored as encrypted data, the contract must first verify that the query is indeed from the token owner before revealing the information. This is where the EIP712 signatures step in."}),"\n",(0,s.jsx)(t.p,{children:"Below is a function from an EncryptedERC20 contract:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"function balanceOf(\n    bytes32 publicKey,\n    bytes calldata signature\n)\n    public\n    view\n    onlySignedPublicKey(publicKey, signature)\n    returns (bytes memory)\n{\n    return TFHE.reencrypt(balances[msg.sender], publicKey);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In this function, ",(0,s.jsx)(t.code,{children:"onlySignedPublicKey"})," is a modifier that verifies if the EIP712 signature is valid. If the signature corresponds to the account that is making the call (",(0,s.jsx)(t.code,{children:"msg.sender"}),"), then the function will execute. If not, it will revert."]}),"\n",(0,s.jsxs)(t.p,{children:["Here's what the ",(0,s.jsx)(t.code,{children:"onlySignedPublicKey"})," modifier looks like:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:'modifier onlySignedPublicKey(bytes32 publicKey, bytes memory signature) {\n    bytes32 digest = _hashTypedDataV4(\n        keccak256(\n            abi.encode(keccak256("Reencrypt(bytes32 publicKey)"), publicKey)\n        )\n    );\n    address signer = ECDSA.recover(digest, signature);\n    require(\n        signer == msg.sender,\n        "EIP712 signer and transaction signer do not match"\n    );\n    _;\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"onlySignedPublicKey"})," modifier takes a ",(0,s.jsx)(t.code,{children:"publicKey"})," and ",(0,s.jsx)(t.code,{children:"signature"}),". It then calculates the ",(0,s.jsx)(t.code,{children:"digest"})," from the ",(0,s.jsx)(t.code,{children:"publicKey"}),". The signer's address is recovered from the ",(0,s.jsx)(t.code,{children:"digest"})," using the ",(0,s.jsx)(t.code,{children:"ECDSA.recover"})," function. If the recovered address matches ",(0,s.jsx)(t.code,{children:"msg.sender"}),", it means that the caller is indeed the owner of the account and is allowed to access the data."]}),"\n",(0,s.jsxs)(t.p,{children:["fhEVM solidity library comes with a helper contract ",(0,s.jsx)(t.a,{href:"https://github.com/zama-ai/fhevm-solidity/blob/main/abstracts/EIP712WithModifier.sol",children:"EIP712WithModifier.sol"})," which includes the snippet above and can be easily imported to integrate into your contracts. See ",(0,s.jsx)(t.a,{href:"https://github.com/FhenixProtocol/devnet-contracts/blob/main/EncryptedERC20.sol",children:"EncryptedERC20.sol"})," for a full example how this is done."]}),"\n",(0,s.jsx)(t.h4,{id:"advanced-access-control",children:"Advanced Access Control"}),"\n",(0,s.jsx)(t.p,{children:"While the above-mentioned access control scheme leveraging EIP712 signatures provides a robust mechanism for verifying the identity of users querying encrypted data, it does have some limitations. One of the primary missing pieces is the absence of roles and permissions associated with those roles. The scheme as described validates that a user querying a balance, for example, is indeed the owner of that account, but it doesn't provide a mechanism for defining different levels of access or permissions."}),"\n",(0,s.jsx)(t.p,{children:"For instance, in more complex scenarios, you might want to allow certain users to only view specific pieces of data, or perhaps perform certain actions based on their role (admin, user, auditor, etc.). Moreover, there's no provision for dynamic access control in which permissions could be granted or revoked at runtime."}),"\n",(0,s.jsx)(t.p,{children:"Additionally, this scheme doesn't cover collective authority, where, for example, an action might require the approval of multiple participants to be executed. Such advanced access control mechanisms are not built into this scheme and would need to be implemented separately based on specific application needs."}),"\n",(0,s.jsx)(t.p,{children:"Lastly, the EIP-712 standard mostly considers messages targeted at a single smart contract. Some use-cases, however, benefit from allowing the user to provide access to multiple contracts concurrently. For example, consider a DeX (decentralized exchange). Allowing such an app to be able to display the balances of all the user's different tokens would be a UX challenge if the user had to approve each one individually.   "}),"\n",(0,s.jsx)(t.h3,{id:"standardization",children:"Standardization"}),"\n",(0,s.jsx)(t.p,{children:"While we recommend and provide Permits as a basic access control mechanism, we do not enforce any particular standard for them.\nWe feel that as the ecosystem evolves, different standards will emerge and we do not want to limit the ecosystem by enforcing a particular standard at this stage."}),"\n",(0,s.jsx)(t.p,{children:"In other words, if you think there is a better way to do it, feel free to do so!"})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var s=n(7294);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);