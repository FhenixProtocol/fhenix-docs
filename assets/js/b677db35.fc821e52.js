"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[4027],{7788:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>d,metadata:()=>c,toc:()=>a});var s=t(4848),i=t(8453);const d={sidebar_position:2.5,title:"\ud83d\udc49 Inputs",description:"How to handle encrypted data coming from the user"},r="Handling Encrypted Inputs",c={id:"devdocs/Writing Smart Contracts/User-Inputs",title:"\ud83d\udc49 Inputs",description:"How to handle encrypted data coming from the user",source:"@site/versioned_docs/version-Helium/devdocs/Writing Smart Contracts/User-Inputs.md",sourceDirName:"devdocs/Writing Smart Contracts",slug:"/devdocs/Writing Smart Contracts/User-Inputs",permalink:"/docs/Helium/devdocs/Writing Smart Contracts/User-Inputs",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/tree/main/versioned_docs/version-Helium/devdocs/Writing Smart Contracts/User-Inputs.md",tags:[],version:"Helium",sidebarPosition:2.5,frontMatter:{sidebar_position:2.5,title:"\ud83d\udc49 Inputs",description:"How to handle encrypted data coming from the user"},sidebar:"docsSidebar",previous:{title:"\ud83d\udc24 Getting Started",permalink:"/docs/Helium/devdocs/Writing Smart Contracts/FHE-sol"},next:{title:"\ud83d\udc48 Outputs",permalink:"/docs/Helium/devdocs/Writing Smart Contracts/Returning-Data"}},o={},a=[{value:"Overview",id:"overview",level:2},{value:"Encrypted Data Types",id:"encrypted-data-types",level:2},{value:"Receiving Encrypted Inputs",id:"receiving-encrypted-inputs",level:2},{value:"<code>inEuintXX</code> Structs",id:"ineuintxx-structs",level:3},{value:"Raw Bytes",id:"raw-bytes",level:3},{value:"Advantages of <code>inEuint</code>, <code>inEbool</code> and <code>inEaddress</code> Over Raw Bytes",id:"advantages-of-ineuint-inebool-and-ineaddress-over-raw-bytes",level:2},{value:"Examples",id:"examples",level:3},{value:"Voting in a Poll",id:"voting-in-a-poll",level:4},{value:"Setting Encrypted User Preferences",id:"setting-encrypted-user-preferences",level:4},{value:"<code>inExxx</code> vs. <code>exxx</code> Types",id:"inexxx-vs-exxx-types",level:3},{value:"Conversion Requirement",id:"conversion-requirement",level:3},{value:"Gas Cost Implications",id:"gas-cost-implications",level:3},{value:"Best Practices \u2013 Use Structured Types",id:"best-practices--use-structured-types",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"handling-encrypted-inputs",children:"Handling Encrypted Inputs"}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Fhenix\u2019s Fully Homomorphic Encryption (FHE) smart contracts handle encrypted data input differently from standard Solidity smart contracts."}),"\n",(0,s.jsxs)(n.p,{children:["First, Fhenix has different data types: boolean, integer and user input.\nSecond, ",(0,s.jsx)(n.code,{children:"inEuint"})," and ",(0,s.jsx)(n.code,{children:"inEbool"})," are used for handling input data, whereas ",(0,s.jsx)(n.code,{children:"euint"})," and ",(0,s.jsx)(n.code,{children:"ebool"})," are used for already processed data within the contract.\nThird, conversion is required from ",(0,s.jsx)(n.code,{children:"inEuint"})," to ",(0,s.jsx)(n.code,{children:"euint"})," to ensure that only correctly formatted encrypted user input is processed. This is done using a helper function: ",(0,s.jsx)(n.code,{children:"FHE.asEuintxx"}),".\nFinally, follow best practices. Try to minimize storing large quantities of encrypted data on-chain & optimize computation to lower gas costs; process data as needed. Also, use structured types, and avoid using raw bytes to handle encrypted data input."]}),"\n",(0,s.jsx)(n.h2,{id:"encrypted-data-types",children:"Encrypted Data Types"}),"\n",(0,s.jsx)(n.p,{children:"Different types of encrypted data can be defined:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inEbool"}),": Encrypted boolean."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inEuint8"}),": Encrypted unsigned 8-bit integer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inEuint16"}),": Encrypted unsigned 16-bit integer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inEuint32"}),": Encrypted unsigned 32-bit integer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inEuint64"}),": Encrypted unsigned 64-bit integer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inEuint128"}),": Encrypted unsigned 128-bit integer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inEuint256"}),": Encrypted unsigned 256-bit integer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inEaddress"}),": Encrypted address."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"receiving-encrypted-inputs",children:"Receiving Encrypted Inputs"}),"\n",(0,s.jsxs)(n.p,{children:["Two methods can be used to receive encrypted inputs: ",(0,s.jsx)(n.code,{children:"inEuintXX"})," structs or raw bytes."]}),"\n",(0,s.jsx)(n.p,{children:"The following code snippets show how to use the two methods for an encrypted transfer to a specific Contract on the blockchain:"}),"\n",(0,s.jsxs)(n.h3,{id:"ineuintxx-structs",children:[(0,s.jsx)(n.code,{children:"inEuintXX"})," Structs"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"   function transferEncryptedToAccount(address to, inEuint32 calldata encryptedBalance) public {\n     _updateAccountBalance(to, FHE.asEuint32(encryptedBalance));\n   }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"raw-bytes",children:"Raw Bytes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"    function transferEncryptedData(address to, bytes calldata encryptedData) public {\n        _storeEncryptedData(to, FHE.asEuint32(encryptedData));\n    }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, the advantage of using ",(0,s.jsx)(n.code,{children:"inEuint"})," over raw bytes is that it ensures type safety and readability. It also provides a structured approach that integrates well with the FHE.sol and fhenix.js library's functions."]}),"\n",(0,s.jsxs)(n.h2,{id:"advantages-of-ineuint-inebool-and-ineaddress-over-raw-bytes",children:["Advantages of ",(0,s.jsx)(n.code,{children:"inEuint"}),", ",(0,s.jsx)(n.code,{children:"inEbool"})," and ",(0,s.jsx)(n.code,{children:"inEaddress"})," Over Raw Bytes"]}),"\n",(0,s.jsxs)(n.p,{children:["Fhenix strongly recommends using ",(0,s.jsx)(n.code,{children:"inEuintxx"})," (and/or ",(0,s.jsx)(n.code,{children:"inEbool"}),", ",(0,s.jsx)(n.code,{children:"inEaddress"}),") structs instead of raw bytes to ensure type safety and readability. These structs provide a structured approach that integrates well with FHE.sol library functions. We believe that the advantages of ",(0,s.jsx)(n.code,{children:"inEuintxx"}),", ",(0,s.jsx)(n.code,{children:"inEbool"})," and ",(0,s.jsx)(n.code,{children:"inEaddress"})," structs are more compatible with handling encrypted data and ensuring application safety, even though raw bytes may result in very slightly lower gas costs."]}),"\n",(0,s.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h4,{id:"voting-in-a-poll",children:"Voting in a Poll"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"  function castEncryptedVote(address poll, inEbool calldata encryptedVote) public {\n    _submitVote(poll, FHE.asEbool(encryptedVote));\n  }\n"})}),"\n",(0,s.jsx)(n.h4,{id:"setting-encrypted-user-preferences",children:"Setting Encrypted User Preferences"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"   function updateUserSetting(address user, inEuint8 calldata encryptedSetting) public {\n       _applyUserSetting(user, FHE.asEuint8(encryptedSetting));\n   }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"inexxx-vs-exxx-types",children:[(0,s.jsx)(n.code,{children:"inExxx"})," vs. ",(0,s.jsx)(n.code,{children:"exxx"})," Types"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inExxx"})," types, such as all of ",(0,s.jsx)(n.code,{children:"inEuint"})," types, ",(0,s.jsx)(n.code,{children:"inEbool"})," and ",(0,s.jsx)(n.code,{children:"inEaddress"})," types are used for handling incoming encrypted data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exxx"})," types such as all of ",(0,s.jsx)(n.code,{children:"euint"})," types, ",(0,s.jsx)(n.code,{children:"ebool"})," and ",(0,s.jsx)(n.code,{children:"eaddress"})," are used for data already processed and in use within the contract."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"conversion-requirement",children:"Conversion Requirement"}),"\n",(0,s.jsxs)(n.p,{children:["Conversion from ",(0,s.jsx)(n.code,{children:"inEuint"})," (or ",(0,s.jsx)(n.code,{children:"inEbool"}),", ",(0,s.jsx)(n.code,{children:"inEaddress"}),") to ",(0,s.jsx)(n.code,{children:"euint"})," (",(0,s.jsx)(n.code,{children:"ebool"}),", ",(0,s.jsx)(n.code,{children:"eaddress"}),") is required to ensure that only correctly formatted encrypted data is processed."]}),"\n",(0,s.jsxs)(n.p,{children:["This is done using the ",(0,s.jsx)(n.code,{children:"FHE.asEuintXX"}),", ",(0,s.jsx)(n.code,{children:"FHE.asEbool"})," or ",(0,s.jsx)(n.code,{children:"FHE.asEaddress"})," functions, where ",(0,s.jsx)(n.code,{children:"XX"})," is the bit size of the encrypted data. The example above uses the ",(0,s.jsx)(n.code,{children:"FHE.asEuint8"})," helper function."]}),"\n",(0,s.jsx)(n.h3,{id:"gas-cost-implications",children:"Gas Cost Implications"}),"\n",(0,s.jsxs)(n.p,{children:["Attempting to store ",(0,s.jsx)(n.code,{children:"inEuint"}),", ",(0,s.jsx)(n.code,{children:"inEbool"})," or ",(0,s.jsx)(n.code,{children:"inEaddress"})," types directly in storage can lead to prohibitively high gas costs due to the large size of encrypted data. It's generally recommended to avoid storing these directly and instead process them as needed."]}),"\n",(0,s.jsx)(n.h3,{id:"best-practices--use-structured-types",children:"Best Practices \u2013 Use Structured Types"}),"\n",(0,s.jsxs)(n.p,{children:["Ensure data integrity and security of smart contract operation when handling encrypted input. Use the structured ",(0,s.jsx)(n.code,{children:"inEuint"}),", ",(0,s.jsx)(n.code,{children:"inEbool"})," or ",(0,s.jsx)(n.code,{children:"inEaddress"})," types for clearer and safer code, and be mindful of gas costs when designing your contract's data handling strategies. Thorough testing and consideration of security implications are essential in maintaining the robustness and reliability of your FHE-based smart contracts."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(6540);const i={},d=s.createContext(i);function r(e){const n=s.useContext(d);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(d.Provider,{value:n},e.children)}}}]);