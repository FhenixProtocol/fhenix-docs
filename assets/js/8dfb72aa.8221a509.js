"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[7844],{9861:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>l,frontMatter:()=>c,metadata:()=>i,toc:()=>d});var s=t(5893),a=t(1151);const c={sidebar_position:4},r="End-to-End Example",i={id:"devdocs/FhenixJS/Sending-a-Transaction",title:"End-to-End Example",description:"In this section, we'll explore how to use fhenixjs to send transactions on the Fhenix blockchain.",source:"@site/docs/devdocs/FhenixJS/Sending-a-Transaction.md",sourceDirName:"devdocs/FhenixJS",slug:"/devdocs/FhenixJS/Sending-a-Transaction",permalink:"/fhenix-docs/docs/devdocs/FhenixJS/Sending-a-Transaction",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/main/docs/devdocs/FhenixJS/Sending-a-Transaction.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"(Un)Sealing",permalink:"/fhenix-docs/docs/devdocs/FhenixJS/Decryption"},next:{title:"Network Keys",permalink:"/fhenix-docs/docs/devdocs/FhenixJS/Network Keys"}},o={},d=[{value:"Putting it all together",id:"putting-it-all-together",level:4}];function h(n){const e={a:"a",code:"code",h1:"h1",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"end-to-end-example",children:"End-to-End Example"}),"\n",(0,s.jsx)(e.p,{children:"In this section, we'll explore how to use fhenixjs to send transactions on the Fhenix blockchain."}),"\n",(0,s.jsx)(e.p,{children:"To send transactions with fhenixjs, we'll first establish a connection to the blockchain, then interact with it using a contract method. For this process, we'll also need to encrypt the transaction data."}),"\n",(0,s.jsxs)(e.p,{children:["Here's a step-by-step explanation, using ",(0,s.jsx)(e.code,{children:"ethers"}),", though other libraries like ",(0,s.jsx)(e.code,{children:"web3"}),"can also be used in a similar way. "]}),"\n",(0,s.jsxs)(e.p,{children:["Let's assume we have a deployed ERC20 contract, only this one uses encrypted inputs and outputs (you can find the solidity code ",(0,s.jsx)(e.a,{href:"../../examples/reference-dapps/encrypted-erc20/",children:"here"}),"). Let's see how we can transfer some of our tokens to another address, while keeping the amount hidden."]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Import fhenixjs and ethers"})}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"import * as fhenixjs from 'fhenixjs';\nimport ethers from 'ethers';\n"})}),"\n",(0,s.jsxs)(e.ol,{start:"2",children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Define the Smart Contract Address and Provider:"})," The smart contract address is the Ethereum address of the deployed contract. ",(0,s.jsx)(e.code,{children:"provider"})," is an instance of the ethers.js library's ",(0,s.jsx)(e.code,{children:"Web3Provider"})," which allows you to interact with the Ethereum blockchain."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const CONTRACT_ADDRESS = '0x1c786b8ca49D932AFaDCEc00827352B503edf16c';\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\n"})}),"\n",(0,s.jsxs)(e.ol,{start:"3",children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Create an Instance of the fhenixjs:"})," The ",(0,s.jsx)(e.code,{children:"createInstance"})," function is used to create an instance of fhenixjs with the current blockchain parameters (chainId and publicKey)."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const getInstance = async () => {\n  // if you want to use a singleton pattern\n  if (_instance) return _instance;\n  \n  // Get chain id\n  const chainId = await provider.getNetwork()\n  console.log(`what dis: ${chainId.chainId}`)\n\n  // Get blockchain public key\n  const publicKey = await provider.call({ \n    to: '0x0000000000000000000000000000000000000044' \n  });\n\n  // Create instance\n  _instance = createInstance({ chainId, publicKey });\n  return _instance;\n};\n"})}),"\n",(0,s.jsxs)(e.ol,{start:"4",children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Create the Transfer Function:"})," The ",(0,s.jsx)(e.code,{children:"transfer"})," function is used to send a transaction on the blockchain. It requires the recipient address and the amount to be sent as parameters."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const transfer = async (to, amount) => {\n  // Initialize contract\n  const contract = new Contract(abi, CONTRACT_ADDRESS);\n\n  // Get instance to encrypt amount parameter\n  const instance = await getInstance();\n  const encryptedAmount = instance.encrypt32(amount);\n\n  const transaction = await contract.methods.transfer(address, encryptedAmount);\n  return transaction;\n};\n"})}),"\n",(0,s.jsxs)(e.p,{children:["In the ",(0,s.jsx)(e.code,{children:"transfer"})," function:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"First, an instance of the contract is initialized using the ABI and the contract address."}),"\n",(0,s.jsxs)(e.li,{children:["The ",(0,s.jsx)(e.code,{children:"getInstance"})," function is called to get an instance of fhenixjs. The instance is then used to encrypt the transaction amount. The ",(0,s.jsx)(e.code,{children:"encrypt32"})," function of fhenixjs is used to encrypt a 32-byte value. The encrypted value is passed as a parameter to the transfer method of the contract."]}),"\n",(0,s.jsxs)(e.li,{children:["The transaction is sent using the ",(0,s.jsx)(e.code,{children:"contract.methods.transfer"})," function. The ",(0,s.jsx)(e.code,{children:"transfer"})," method of the contract requires the recipient address and the encrypted amount as parameters. The function returns the transaction."]}),"\n"]}),"\n",(0,s.jsx)(e.h4,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const { createInstance } = require('fhenixjs');\nconst { Wallet, JsonRpcProvider, Contract } = require('ethers');\n\nconst contractInfo = require('./EncryptedERC20.json');\n\nconst CONTRACT_ADDRESS = '0x309cf2aae85ad8a1db70ca88cfd4225bf17a7482';\n\nconst provider = new JsonRpcProvider(`https://devnet.zama.ai/`);\n\nconst signer = new Wallet('0x92293977156de6e03b20b26708cb4496b523116190b5c32d77cee8286d0c41f6', provider);\n\nlet _instance;\n\nconst getInstance = async () => {\n  if (_instance) return _instance;\n\n  // 1. Get chain id\n  const network = await provider.getNetwork();\n  const chainId = +network.chainId.toString(); // Need to be a number\n\n  // Get global public key\n  const publicKey = await provider.call({ to: '0x0000000000000000000000000000000000000044' });\n\n  // Create instance\n  _instance = createInstance({ chainId, publicKey });\n  return _instance;\n};\n\nconst transfer = async (to, amount) => {\n  // Initialize contract with ethers\n  const contract = new Contract(CONTRACT_ADDRESS, contractInfo.abi, signer);\n  // Get instance to encrypt amount parameter\n  const instance = await getInstance();\n  const encryptedAmount = instance.encrypt32(amount);\n\n  const transaction = await contract['transfer(address,bytes)'](to, encryptedAmount);\n  return transaction;\n};\n\ntransfer('0xa83a498Eee26f9594E3A784f204e507a5Fae3210', 10);\n"})})]})}function l(n={}){const{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}},1151:(n,e,t)=>{t.d(e,{Z:()=>i,a:()=>r});var s=t(7294);const a={},c=s.createContext(a);function r(n){const e=s.useContext(c);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),s.createElement(c.Provider,{value:e},n.children)}}}]);