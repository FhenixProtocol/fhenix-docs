"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[5430],{2999:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var i=n(4848),s=n(8453);const r={sidebar_position:6,title:"\ud83d\udd75\ufe0f Permissions",description:"Managing access to sensitive data & Permissioned contracts"},o=void 0,a={id:"devdocs/Writing Smart Contracts/Permissions",title:"\ud83d\udd75\ufe0f Permissions",description:"Managing access to sensitive data & Permissioned contracts",source:"@site/docs/devdocs/Writing Smart Contracts/Permissions.md",sourceDirName:"devdocs/Writing Smart Contracts",slug:"/devdocs/Writing Smart Contracts/Permissions",permalink:"/docs/devdocs/Writing Smart Contracts/Permissions",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/tree/main/docs/devdocs/Writing Smart Contracts/Permissions.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"\ud83d\udd75\ufe0f Permissions",description:"Managing access to sensitive data & Permissioned contracts"},sidebar:"docsSidebar",previous:{title:"\ud83d\udea6Require Statements",permalink:"/docs/devdocs/Writing Smart Contracts/Requires"},next:{title:"\ud83e\uddd9 Type Conversions",permalink:"/docs/devdocs/Writing Smart Contracts/Converting-between-Types"}},c={},d=[{value:"Overview",id:"overview",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"How to Use",id:"how-to-use",level:2},{value:"Example Scenario 1",id:"example-scenario-1",level:2},{value:"Example Scenario 2",id:"example-scenario-2",level:2},{value:"Notes",id:"notes",level:2}];function l(e){const t={admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"Permissioned"})," contract is an abstract Solidity contract that leverages EIP-712 standard signatures to enforce access controls. It's designed to be used by developers who require signature verification to restrict access to certain contract functions. While it can be used to restrict any kind of function, it's particularly useful for creating access-controlled view functions where data should only be visible to entities with a verified signature."]}),"\n",(0,i.jsx)(t.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsx)(t.p,{children:"One of the common use cases for such access control is in scenarios where sensitive information must be retrieved from a contract but should not be publicly accessible. For example, a contract managing private user data may implement view functions that require a signature to confirm the identity of the requester. This ensures that only the user or an authorized party can access that user's data."}),"\n",(0,i.jsx)(t.h2,{id:"how-to-use",children:"How to Use"}),"\n",(0,i.jsxs)(t.p,{children:["To utilize the ",(0,i.jsx)(t.code,{children:"Permissioned"})," contract, you would inherit it in your own contract and apply the custom modifiers to the functions you want to protect. To implement access-controlled view functions, follow these steps:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Define a view function in your contract. For example, to retrieve sensitive data:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"function getSensitiveData(Permission calldata perm) public view onlySender(perm) returns (string memory) {\n    // Logic to return sensitive data\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Off-chain, the user generates a signature over their request using EIP-712 signed with their private key. This process typically involves structured data that lists the types of variables involved and their values. The result is a signature that proves the user consents to the requested operation."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Call the view function with the generated signature as one of the parameters. Only if the signature is verified and corresponds to the ",(0,i.jsx)(t.code,{children:"msg.sender"})," will the view function execute and return the sensitive data."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"example-scenario-1",children:"Example Scenario 1"}),"\n",(0,i.jsx)(t.p,{children:"Imagine a contract holding medical records. You want to create a secure method for patients to view their records:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'pragma solidity ^0.8.20;\n\nimport "@fhenixprotocol/contracts/access/Permissioned.sol";\n\ncontract MedicalRecords is Permissioned {\n    \n    mapping(address => string) private records;\n\n    function viewMedicalRecord(Permission calldata perm) public view onlySender(perm) returns (string memory) {\n        return records[msg.sender];\n    }\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"The patient, after obtaining the appropriate signature using their private key, would submit it along with their request to view their records. The contract verifies the signature against the caller's address, and if it matches, returns the patient\u2019s medical record."}),"\n",(0,i.jsx)(t.admonition,{type:"danger",children:(0,i.jsxs)(t.p,{children:["In this example we are just showcasing the usage of permissions. ",(0,i.jsx)(t.code,{children:"string"})," and ",(0,i.jsx)(t.code,{children:"address"})," are still public data types and can be read directly from the chain!"]})}),"\n",(0,i.jsx)(t.h2,{id:"example-scenario-2",children:"Example Scenario 2"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'pragma solidity ^0.8.20;\nimport {FHE, euint8, inEuint8} from "@fhenixprotocol/contracts/FHE.sol";\ncontract Test {\n    euint8 _output;\n\n    function setOutput(inEuint8 calldata _encryptedNumber) public  {\n        // convert inEuint8 type structure to euint8 \n        _output = FHE.asEuint8(_encryptedNumber);\n    }\n\n    function getSealedOutput(Permission memory signature) public view  returns (string memory) {\n        // Seal the output for a specific publicKey\n        return FHE.sealoutput(_output, signature.publicKey);\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Permissioned view functions only allow access upon successful signature verification, enhancing contract's data privacy."}),"\n",(0,i.jsx)(t.li,{children:"Users need to protect their private keys used to generate EIP-712 signatures to maintain the integrity of the access control system."}),"\n",(0,i.jsx)(t.li,{children:"Developers must integrate off-chain EIP-712 compliant signing processes to ensure users can generate valid signatures for contract interactions."}),"\n",(0,i.jsx)(t.li,{children:"EIP-712 signatures provide strong assurances of user intention, making them ideal for sensitive operations."}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(6540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);