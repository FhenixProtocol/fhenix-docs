"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[923],{7223:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var a=t(4848),r=t(8453);const s={},o="Randomness",i={id:"devdocs/Writing Smart Contracts/Randomness",title:"Randomness",description:"Randomness was introduced in the Nitrogen testnet.",source:"@site/docs/devdocs/Writing Smart Contracts/Randomness.md",sourceDirName:"devdocs/Writing Smart Contracts",slug:"/devdocs/Writing Smart Contracts/Randomness",permalink:"/docs/./devdocs/Writing Smart Contracts/Randomness",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/tree/main/docs/devdocs/Writing Smart Contracts/Randomness.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"\ud83d\udd25 Gas and Benchmarks",permalink:"/docs/./devdocs/Writing Smart Contracts/Gas-and-Benchmarks"},next:{title:"Overview",permalink:"/docs/./devdocs/Setting Up Your Environment/intro"}},c={},d=[{value:"Best practice: Ensure caller is not a Contract",id:"best-practice-ensure-caller-is-not-a-contract",level:3},{value:"Randomness in View functions",id:"randomness-in-view-functions",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"randomness",children:"Randomness"}),"\n",(0,a.jsxs)(n.p,{children:["Randomness was introduced in the Nitrogen testnet.\nContracts in Fhenix can get random numbers by calling one of the randomness functions in ",(0,a.jsx)(n.code,{children:"FHE.sol"}),".\nThese functions are:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'import {\n    FHE, euint8, euint16, euint32, euint64, euint128, euint256\n} from "@fhenixprotocol/contracts/FHE.sol";\n\neuint8 randomValue = FHE.randomEuint8();\neuint16 randomValue = FHE.randomEuint16();\neuint32 randomValue = FHE.randomEuint32();\neuint64 randomValue = FHE.randomEuint64();\neuint128 randomValue = FHE.randomEuint128();\neuint256 randomValue = FHE.randomEuint256();\n'})}),"\n",(0,a.jsx)(n.p,{children:"Note that the random values are returned as encrypted values.\nThis is a fundamental quality of randomness generation, because if the returned value\nwas plaintext, then it would be possible to simulate the execution and predict the random value."}),"\n",(0,a.jsxs)(n.p,{children:["To see the randomness functions as part of a full example take a look at the ",(0,a.jsx)(n.a,{href:"https://github.com/FhenixProtocol/rng-binary-guessing-game-demo",children:"rng-binary-guessing-game"})," example repo."]}),"\n",(0,a.jsx)(n.h3,{id:"best-practice-ensure-caller-is-not-a-contract",children:"Best practice: Ensure caller is not a Contract"}),"\n",(0,a.jsx)(n.p,{children:"When acting upon the resulting random numbers, it is important to keep the following\nscenario in mind."}),"\n",(0,a.jsxs)(n.p,{children:["Suppose we have a simple game contract that you can send funds to, and with a probability of ",(0,a.jsx)(n.code,{children:"P=0.5"})," (or, 50% chance),\nyou will receive double the funds back."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'contract RandomLucky {\n    function play() external payable {\n        require(msg.value > 0, "You need to send some FHE");\n\n        // Generate a random encrypted number\n        euint8 outcome = FHE.randomEuint8();\n        uint8 outcomeDecrypted = outcome.decrypt();\n\n        // If the outcome is even, send double the value back to the sender\n        if (outcomeDecrypted % 2 == 0) {\n            uint prize = msg.value * 2;\n            require(address(this).balance >= prize, "Contract does not have enough balance");\n            payable(msg.sender).transfer(prize);\n        }\n        // If the outcome is odd, the contract keeps the value\n    }\n\n    // Fallback function to receive FHE\n    receive() external payable {}\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"An adversary could could call the randomness consumer function, check the result of the random,\nand revert the transaction if that result were not favorable."}),"\n",(0,a.jsx)(n.p,{children:"In this case:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'contract Adversary {\n    RandomLucky game;\n\n    constructor(address gameAddress) {\n        game = RandomLucky(gameAddress);\n    }\n\n    // Function to attack the RandomLucky contract\n    function attack() public payable {\n        require(msg.value > 0, "Must send some FHE to attack");\n\n        // Store the initial balance of the contract\n        uint256 initialBalance = address(this).balance;\n\n        // Call the play function of the RandomLucky contract\n        game.play{value: msg.value}();\n\n        // Check if the balance did not increase\n        if (address(this).balance <= initialBalance) {\n            revert("Did not win, reverting transaction");\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"To prevent this kind of attacks, it is recommended to not allow contracts\nto call functions that act upon random numbers, like so:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'modifier callerIsUser() {\n  require(tx.origin == msg.sender, "The caller is another contract");\n  _;\n}\n\nfunction play() callerIsUser {\n  ...\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["If your randomness consumer function ",(0,a.jsx)(n.em,{children:"must"})," be callable by another contract, it is recommended to split the consumption and reveal into separate functions:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'struct UserData {\n    uint256 amount;\n    euint8 outcome;\n    uint256 block;\n    bool revealed;\n}\n\nmapping (address => UserData) private userData;\n\nfunction play() external payable {\n    require(msg.value > 0, "You need to send some FHE");\n    require(userData[msg.sender].amount == 0, "Already playing")\n\n    // Store the amount played and the outcome to be revealed later\n    userData[msg.sender] = UserData({\n        amount: msg.value,\n        outcome: FHE.randomEuint8(),\n        block: block.number,\n        revealed: false\n    });\n}\n\nfunction reveal() external {\n    UserData storage data = userData[msg.sender];\n\n    // Ensure that random number cannot be consumed and revealed in the same block\n    require(block.number > data.block, "Cannot reveal in same block");\n    require(!data.revealed, "Already revealed");\n\n    uint8 outcomeDecrypted = data.outcome.decrypt();\n    if (outcomeDecrypted % 2 == 0) {\n        uint256 prize = data.amount * 2;\n        require(address(this).balance >= (prize), "Contract does not have enough balance");\n        payable(msg.sender).transfer(prize);\n    }\n\n    data.amount = 0;\n    data.revealed = true;\n}\n'})}),"\n",(0,a.jsxs)(n.admonition,{title:"Warning",type:"danger",children:[(0,a.jsx)(n.h3,{id:"randomness-in-view-functions",children:"Randomness in View functions"}),(0,a.jsxs)(n.p,{children:["Randomness is guaranteed to be unique for each transaction, but not for each ",(0,a.jsx)(n.code,{children:"eth_call"}),".\nSpecifically, two eth_calls to the same contract, on the same block may receive the same random value (more on this below)."]})]}),"\n",(0,a.jsxs)(n.admonition,{title:"How does it work?",type:"info",children:[(0,a.jsx)(n.p,{children:"Random generation takes as input a seed, and returns a random number which is unique for each seed and key sets."}),(0,a.jsx)(n.p,{children:"To cause each random to be different for each transaction, the seed is created from a) the contract address,\nb) the transaction hash, and c) a counter that gets incremented each transaction."}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"seed = hash(contract_address, tx_hash, counter)\n"})}),(0,a.jsx)(n.p,{children:"For eth calls, which don't have a tx_hash nor can use a counter, we use the block hash instead, that's why two quick subsequent\ncalls to the same contract may return the same random number."}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"seed = hash(contract_address, block_hash)\n"})})]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var a=t(6540);const r={},s=a.createContext(r);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);