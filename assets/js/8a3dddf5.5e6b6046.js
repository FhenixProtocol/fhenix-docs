"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[1921],{614:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var s=t(5893),r=t(1151);const a={},c="Writing the Contract",o={id:"tutorial/Basic/Writing-The-Contract",title:"Writing the Contract",description:"Let's get started.",source:"@site/docs/tutorial/Basic/Writing-The-Contract.md",sourceDirName:"tutorial/Basic",slug:"/tutorial/Basic/Writing-The-Contract",permalink:"/fhenix-docs/docs/tutorial/Basic/Writing-The-Contract",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/main/docs/tutorial/Basic/Writing-The-Contract.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Setting Up",permalink:"/fhenix-docs/docs/tutorial/Basic/Setting-Up"},next:{title:"Advanced",permalink:"/fhenix-docs/docs/category/advanced"}},i={},d=[];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"writing-the-contract",children:"Writing the Contract"}),"\n",(0,s.jsx)(n.p,{children:"Let's get started."}),"\n",(0,s.jsx)(n.p,{children:"We'll start by creating our new contract. We'll use Counter.sol as a template. Let's copy this file and create a new solidity file which we'll call WrappingERC20.sol."}),"\n",(0,s.jsx)(n.admonition,{title:"Tip",type:"tip",children:(0,s.jsx)(n.p,{children:"While we recommend development in an IDE, you can also use an environment like Remix and follow along!"})}),"\n",(0,s.jsx)(n.p,{children:"Our goal is to create an ERC20 that supports shielding balances. Let's run through the different functions, step-by-step and show how we can implement each. We'll also link to more detailed explainations about custom functionality we make use of."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Prerequisites"})}),"\n",(0,s.jsx)(n.p,{children:"Start by importing the OpenZeppelin ERC20 contract, TFHE.sol, solidity version and a license:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Javascript",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport "fhevm/lib/TFHE.sol";\n'})}),"\n",(0,s.jsx)(n.p,{children:"The OpenZeppelin ERC20 contract will provide the basic functionality of the token, while the TFHE.sol is necessary for encryption purposes. We'll also have to install the openzeppelin contracts, since they are not part of the default template."}),"\n",(0,s.jsx)("code",{class:"lang-bash",children:"pnpm install @openzeppelin/contracts"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Creating the Contract"})}),"\n",(0,s.jsxs)(n.p,{children:["The contract ",(0,s.jsx)(n.code,{children:"WrappingERC20"})," is an ERC20 contract. It uses encryption from FHE.sol to keep balances private and only viewable by the holder of the correct decryption key."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"contract WrappingERC20 is ERC20 {\n...\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Initialize encrypted balance"})}),"\n",(0,s.jsxs)(n.p,{children:["An encrypted balance is initialized for each address, ",(0,s.jsx)(n.code,{children:"_encBalances"}),", which will hold encrypted token balances for users. ",(0,s.jsx)(n.a,{href:"../fhevm-solidity/encrypted-types.md",children:"euints"})," are encrypted data types that represent FHE-encrypted unsigned integers of various bit lengths."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"mapping(address => euint32) internal _encBalances;\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The Constructor"})}),"\n",(0,s.jsx)(n.p,{children:"The constructor function sets the name and symbol of the token, and then mints an initial 100 tokens to the address that deploys the contract."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n     _mint(msg.sender, 100 * 10 ** uint(decimals()));\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Wrap and Unwrap"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"wrap"})," and ",(0,s.jsx)(n.code,{children:"unwrap"})," functions are unique to this contract."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"wrap(uint32 amount)"})," allows users to convert (wrap) their tokens into encrypted form. The function burns the specified amount from the user's balance and adds the same amount to their encrypted balance. Note the usage of ",(0,s.jsx)(n.a,{href:"../../more-docs/developer-reference/fhevm-solidity/types-and-operations.md",children:"TFHE.add()"})," to perform addition between two encrypted numbers, which returns an encrypted response."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function wrap(uint32 amount) public {\n    require(balanceOf(msg.sender) >= amount);\n    _burn(msg.sender, amount);\n\n    _encBalances[msg.sender] = TFHE.add(_encBalances[msg.sender], amount);\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"unwrap(uint32 amount)"})," allows users to convert (unwrap) their encrypted tokens back into regular tokens. The function removes the specified amount from the user's encrypted balance and mints the same amount of regular tokens. ",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.br,{}),"\n","At this point, before performing the unwrapping we need to make sure that the caller has enough encrypted tokens to unwrap the requested amount. To do this, we use the special ",(0,s.jsx)(n.a,{href:"../fhevm-solidity/require-vs.-optimistic-require.md",children:"TFHE.req (require)"})," functionality."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function unwrap(uint32 amount) public { \n    TFHE.req(TFHE.gt(_encBalances[msg.sender], amount));\n    _encBalances[msg.sender] = TFHE.sub(_encBalances[msg.sender], amount);\n    _mint(msg.sender, amount);\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Encrypted Transfers"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"transferEncrypted(address to, bytes calldata encryptedAmount)"})," is a public function that transfers encrypted tokens from the function caller to the ",(0,s.jsx)(n.code,{children:"to"})," address. It converts the encrypted amount into the encrypted integer form ",(0,s.jsx)(n.code,{children:"euint32"})," using the ",(0,s.jsx)(n.a,{href:"../fhevm-solidity/encrypted-types.md#sending-an-euint",children:(0,s.jsx)(n.code,{children:"TFHE.asEuint32(encryptedAmount)"})})," function and then calls ",(0,s.jsx)(n.code,{children:"_transferEncrypted"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The function ",(0,s.jsx)(n.code,{children:"_transferEncrypted(address to, euint32 amount)"})," is an internal function that just calls ",(0,s.jsx)(n.code,{children:"_transferImpl"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"_transferImpl(address from, address to, euint32 amount)"})," performs the actual transfer. It checks if the sender has enough tokens, then adds the amount to the ",(0,s.jsx)(n.code,{children:"to"})," address encrypted balance and subtracts the same amount from the ",(0,s.jsx)(n.code,{children:"from"})," address encrypted balance."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function transferEncrypted(address to, bytes calldata encryptedAmount) public {\n    _transferEncrypted(to, TFHE.asEuint32(encryptedAmount));\n}\n\n// Transfers an amount from the message sender address to the `to` address.\nfunction _transferEncrypted(address to, euint32 amount) internal {\n    _transferImpl(msg.sender, to, amount);\n}\n\n    // Transfers an encrypted amount.\nfunction _transferImpl(address from, address to, euint32 amount) internal {\n    // Make sure the sender has enough tokens.\n    TFHE.req(TFHE.le(amount, _encBalances[from]));\n\n    // Add to the balance of `to` and subract from the balance of `from`.\n    _encBalances[to] = TFHE.add(_encBalances[to], amount);\n    _encBalances[from] = TFHE.sub(_encBalances[from], amount);\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Encrypted Balance"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.code,{children:"balanceOfEncrypted(address sender, bytes32 publicKey)"})," allows users to check their own encrypted balance. It uses the ",(0,s.jsx)(n.code,{children:"TFHE.reencrypt(_encBalances[sender], publicKey)"})," function which reencrypts the balance with a new key so the original balance cannot be derived from the returned value.\\"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function balanceOfEncrypted(address sender, bytes32 publicKey) \npublic \nview \nreturns (bytes memory)\n{\n    return TFHE.reencrypt(_encBalances[sender], publicKey);\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Did you notice?",type:"tip",children:(0,s.jsxs)(n.p,{children:["We specifically do not include any access-control to the ",(0,s.jsx)(n.code,{children:"balanceOfEncrypted"}),"view function to keep things simple. You can find guidance on EIP712-based schemas in our access control sections of ",(0,s.jsx)(n.a,{href:"../fhevm-solidity/access-control.md",children:"TFHE.sol"})," and ",(0,s.jsx)(n.a,{href:"../fhevm.js/access-control-eip-712.md",children:"fhevmjs"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"Putting it all together, you'll hopefully end up with a contract that looks something like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport "fhevm/lib/TFHE.sol";\n\ncontract WrappingERC20 is ERC20 {\n\n    // A mapping from address to an encrypted balance.\n    mapping(address => euint32) internal _encBalances;\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _mint(msg.sender, 100 * 10 ** uint(decimals()));\n    }\n\n    function wrap(uint32 amount) public {\n        require(balanceOf(msg.sender) >= amount);\n        _burn(msg.sender, amount);\n\n        _encBalances[msg.sender] = TFHE.add(_encBalances[msg.sender], amount);\n    }\n\n    function unwrap(uint32 amount) public {\n        TFHE.req(TFHE.gt(_encBalances[msg.sender], amount));\n\n        _encBalances[msg.sender] = TFHE.sub(_encBalances[msg.sender], amount);\n\n        _mint(msg.sender, amount);\n    }\n\n    function transferEncrypted(address to, bytes calldata encryptedAmount) public {\n        _transferEncrypted(to, TFHE.asEuint32(encryptedAmount));\n    }\n\n    // Transfers an amount from the message sender address to the `to` address.\n    function _transferEncrypted(address to, euint32 amount) internal {\n        _transferImpl(msg.sender, to, amount);\n    }\n\n        // Transfers an encrypted amount.\n    function _transferImpl(address from, address to, euint32 amount) internal {\n        // Make sure the sender has enough tokens.\n        TFHE.req(TFHE.le(amount, _encBalances[from]));\n\n        // Add to the balance of `to` and subract from the balance of `from`.\n        _encBalances[to] = TFHE.add(_encBalances[to], amount);\n        _encBalances[from] = TFHE.sub(_encBalances[from], amount);\n    }\n\n    function balanceOfEncrypted(address sender, bytes32 publicKey) \n    public \n    view \n    returns (bytes memory)\n    {\n        return TFHE.reencrypt(_encBalances[sender], publicKey);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now we can move on to the next stage - checking that the code actually works!"})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>c});var s=t(7294);const r={},a=s.createContext(r);function c(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);