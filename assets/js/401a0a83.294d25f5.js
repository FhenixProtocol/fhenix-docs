"use strict";(self.webpackChunkfhenix_docs=self.webpackChunkfhenix_docs||[]).push([[4530],{9705:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var i=t(5893),s=t(1151);const o={},a="Useful Tips",r={id:"devdocs/Tips/Useful-Tips",title:"Useful Tips",description:"This section will list some useful tips and good practices for you to be able to use them.",source:"@site/docs/devdocs/Tips/Useful-Tips.md",sourceDirName:"devdocs/Tips",slug:"/devdocs/Tips/Useful-Tips",permalink:"/fhenix-docs/docs/devdocs/Tips/Useful-Tips",draft:!1,unlisted:!1,editUrl:"https://github.com/fhenixprotocol/fhenix-docs/main/docs/devdocs/Tips/Useful-Tips.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Tips",permalink:"/fhenix-docs/docs/category/tips"},next:{title:"FHE Contracts",permalink:"/fhenix-docs/docs/category/fhe-contracts"}},l={},d=[{value:"Trivial Encryption",id:"trivial-encryption",level:4},{value:"Default Value of a Euint",id:"default-value-of-a-euint",level:4},{value:"Re-encrypting a Value",id:"re-encrypting-a-value",level:4},{value:"FHE.req() in TXs",id:"fhereq-in-txs",level:4},{value:"Performance and Gas Usage",id:"performance-and-gas-usage",level:4}];function c(e){const n={code:"code",h1:"h1",h4:"h4",p:"p",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"useful-tips",children:"Useful Tips"}),"\n",(0,i.jsx)(n.p,{children:"This section will list some useful tips and good practices for you to be able to use them."}),"\n",(0,i.jsx)(n.h4,{id:"trivial-encryption",children:"Trivial Encryption"}),"\n",(0,i.jsxs)(n.p,{children:["When we are using ",(0,i.jsx)(n.code,{children:"FHE.asEuint*(PLAINTEXT_NUMBER)"})," we are actually using a trivial encryption of our FHE scheme. Unlike normal FHE encryption trivial encryption is a deterministic encryption. The meaning is that if you will do it twice you will still get the same result"]}),"\n",(0,i.jsx)(n.h4,{id:"default-value-of-a-euint",children:"Default Value of a Euint"}),"\n",(0,i.jsxs)(n.p,{children:["When having a ",(0,i.jsx)(n.code,{children:"euint*"})," variable uninitialized it will be considered as 0. Every FHE function that will receive an uninitialized euint* will assume it is ",(0,i.jsx)(n.code,{children:"FHE.asEuint*(0)"}),".\nYou can assume now that ",(0,i.jsx)(n.code,{children:"FHE.asEuint*(0)"}),"is used quite often - Luckily we realized this and decided to have the values of",(0,i.jsx)(n.code,{children:"FHE.asEuint*(0)"}),"pre-calculated on node initialization so when you use",(0,i.jsx)(n.code,{children:"FHE.asEuint\\*(0)"})," we will just return those values."]}),"\n",(0,i.jsx)(n.h4,{id:"re-encrypting-a-value",children:"Re-encrypting a Value"}),"\n",(0,i.jsx)(n.p,{children:"To explain this tip we will use an example. Let's assume we want to develop a confidential voting and let's say we have 4 candidates.\nAssuming that on each vote we increase (cryptographically with FHE.add) the tally, one can just monitor the key in the DB that represents this specific tally and once the key was changes he will know who we voted for.\nAn ideal solution for this issue is to change all keys no matter who we voted for, but how?!\nIn order to understand how we will first need to understand that FHE encryption is a non-deterministic encryption means that encrypting (non-trivial encryption) a number twice will result with 2 different encrypted outputs.\nNow that we know that, we can add 0 (cryptographically with FHE.add) to all of those tallies that shouldn't be changed and they will be changed in the DB!"}),"\n",(0,i.jsx)(n.h4,{id:"fhereq-in-txs",children:"FHE.req() in TXs"}),"\n",(0,i.jsx)(n.p,{children:"All of the operations are supported both in TXs and in Queries. That being said we strongly advice to think twice before you use those operations inside a TX. FHE.req() is actually exposing the value of your encrypted data. Assuming we will send the transaction and monitor the gas usage we can probably identify whether the FHE.req() condition met or not and understand a lot about what the encrypted values represent"}),"\n",(0,i.jsx)(n.h4,{id:"performance-and-gas-usage",children:"Performance and Gas Usage"}),"\n",(0,i.jsxs)(n.p,{children:["Currently, we are supporting a lot of FHE operations. Some of them might take a lot of time to compute, some good examples are: Div (5 seconds for euint32), Mul, Rem, and the time will grow depends on the value types you are using.\nWhen writing FHE code we encourage you to use the operations wisely and choose what operation should be used.\nExample: Instead of ",(0,i.jsx)(n.code,{children:"FHE.mul(ENCRYPTED_UINT_32, FHE.asEuint32(2))"})," you can use ",(0,i.jsx)(n.code,{children:"FHE.shl(ENCRYPTED_UINT_32, FHE.asEuint32(1))"})," in some cases ",(0,i.jsx)(n.code,{children:"FHE.div(ENCRYPTED_UINT_32, FHE.asEuint32(2))"})," can be replaced by ",(0,i.jsx)(n.code,{children:"FHE.shr(ENCRYPTED_UINT_32, FHE.asEuint32(1))"})]}),"\n",(0,i.jsx)(n.p,{children:"For more detailed banchmarks please refer to: TBD"})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var i=t(7294);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);